/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.3.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.models;

import java.util.Objects;
import java.util.Arrays;
import com.delphix.dct.models.Tag;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import org.threeten.bp.LocalDate;
import org.threeten.bp.OffsetDateTime;

/**
 * Virtualization Engine Snapshot of a dSource or VDB.
 */
@ApiModel(description = "Virtualization Engine Snapshot of a dSource or VDB.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-19T18:53:50.335381+05:30[Asia/Kolkata]")
public class Snapshot {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_ENGINE_ID = "engine_id";
  @SerializedName(SERIALIZED_NAME_ENGINE_ID)
  private String engineId;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Indicates what type of recovery strategies must be invoked when provisioning from this snapshot.
   */
  @JsonAdapter(ConsistencyEnum.Adapter.class)
  public enum ConsistencyEnum {
    CONSISTENT("CONSISTENT"),
    
    INCONSISTENT("INCONSISTENT"),
    
    CRASH_CONSISTENT("CRASH_CONSISTENT"),
    
    PLUGGABLE("PLUGGABLE");

    private String value;

    ConsistencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConsistencyEnum fromValue(String value) {
      for (ConsistencyEnum b : ConsistencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConsistencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConsistencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConsistencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConsistencyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CONSISTENCY = "consistency";
  @SerializedName(SERIALIZED_NAME_CONSISTENCY)
  private ConsistencyEnum consistency;

  public static final String SERIALIZED_NAME_MISSING_NON_LOGGED_DATA = "missing_non_logged_data";
  @SerializedName(SERIALIZED_NAME_MISSING_NON_LOGGED_DATA)
  private Boolean missingNonLoggedData;

  public static final String SERIALIZED_NAME_DATASET_ID = "dataset_id";
  @SerializedName(SERIALIZED_NAME_DATASET_ID)
  private String datasetId;

  public static final String SERIALIZED_NAME_CREATION_TIME = "creation_time";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private OffsetDateTime creationTime;

  public static final String SERIALIZED_NAME_START_TIMESTAMP = "start_timestamp";
  @SerializedName(SERIALIZED_NAME_START_TIMESTAMP)
  private OffsetDateTime startTimestamp;

  public static final String SERIALIZED_NAME_START_LOCATION = "start_location";
  @SerializedName(SERIALIZED_NAME_START_LOCATION)
  private String startLocation;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private OffsetDateTime timestamp;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_RETENTION = "retention";
  @SerializedName(SERIALIZED_NAME_RETENTION)
  private Long retention;

  public static final String SERIALIZED_NAME_EXPIRATION = "expiration";
  @SerializedName(SERIALIZED_NAME_EXPIRATION)
  private LocalDate expiration;

  public static final String SERIALIZED_NAME_RETAIN_FOREVER = "retain_forever";
  @SerializedName(SERIALIZED_NAME_RETAIN_FOREVER)
  private Boolean retainForever;

  public static final String SERIALIZED_NAME_EFFECTIVE_EXPIRATION = "effective_expiration";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_EXPIRATION)
  private LocalDate effectiveExpiration;

  public static final String SERIALIZED_NAME_EFFECTIVE_RETAIN_FOREVER = "effective_retain_forever";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_RETAIN_FOREVER)
  private Boolean effectiveRetainForever;

  public static final String SERIALIZED_NAME_TIMEFLOW_ID = "timeflow_id";
  @SerializedName(SERIALIZED_NAME_TIMEFLOW_ID)
  private String timeflowId;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  private String timezone;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_TEMPORARY = "temporary";
  @SerializedName(SERIALIZED_NAME_TEMPORARY)
  private Boolean temporary;

  public static final String SERIALIZED_NAME_APPDATA_TOOLKIT = "appdata_toolkit";
  @SerializedName(SERIALIZED_NAME_APPDATA_TOOLKIT)
  private String appdataToolkit;

  public static final String SERIALIZED_NAME_APPDATA_METADATA = "appdata_metadata";
  @SerializedName(SERIALIZED_NAME_APPDATA_METADATA)
  private String appdataMetadata;

  public static final String SERIALIZED_NAME_ASE_DB_ENCRYPTION_KEY = "ase_db_encryption_key";
  @SerializedName(SERIALIZED_NAME_ASE_DB_ENCRYPTION_KEY)
  private String aseDbEncryptionKey;

  public static final String SERIALIZED_NAME_MSSQL_INTERNAL_VERSION = "mssql_internal_version";
  @SerializedName(SERIALIZED_NAME_MSSQL_INTERNAL_VERSION)
  private Integer mssqlInternalVersion;

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_SET_UUID = "mssql_backup_set_uuid";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_SET_UUID)
  private String mssqlBackupSetUuid;

  /**
   * Backup software used to restore the source database backup for this snapshot
   */
  @JsonAdapter(MssqlBackupSoftwareTypeEnum.Adapter.class)
  public enum MssqlBackupSoftwareTypeEnum {
    AZURE_NATIVE("AZURE_NATIVE"),
    
    NATIVE("NATIVE"),
    
    LITESPEED("LITESPEED"),
    
    REDGATE("REDGATE"),
    
    NETBACKUP("NETBACKUP"),
    
    COMMVAULT("COMMVAULT");

    private String value;

    MssqlBackupSoftwareTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MssqlBackupSoftwareTypeEnum fromValue(String value) {
      for (MssqlBackupSoftwareTypeEnum b : MssqlBackupSoftwareTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MssqlBackupSoftwareTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MssqlBackupSoftwareTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MssqlBackupSoftwareTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MssqlBackupSoftwareTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_SOFTWARE_TYPE = "mssql_backup_software_type";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_SOFTWARE_TYPE)
  private MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType;

  /**
   * Backup software used to restore the source database backup for this snapshot
   */
  @JsonAdapter(MssqlBackupLocationTypeEnum.Adapter.class)
  public enum MssqlBackupLocationTypeEnum {
    DISK("DISK"),
    
    AZURE("AZURE"),
    
    BACKUP_SERVER("BACKUP_SERVER");

    private String value;

    MssqlBackupLocationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MssqlBackupLocationTypeEnum fromValue(String value) {
      for (MssqlBackupLocationTypeEnum b : MssqlBackupLocationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MssqlBackupLocationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MssqlBackupLocationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MssqlBackupLocationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MssqlBackupLocationTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_LOCATION_TYPE = "mssql_backup_location_type";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_LOCATION_TYPE)
  private MssqlBackupLocationTypeEnum mssqlBackupLocationType;

  public static final String SERIALIZED_NAME_MSSQL_EMPTY_SNAPSHOT = "mssql_empty_snapshot";
  @SerializedName(SERIALIZED_NAME_MSSQL_EMPTY_SNAPSHOT)
  private Boolean mssqlEmptySnapshot;

  public static final String SERIALIZED_NAME_ORACLE_FROM_PHYSICAL_STANDBY_VDB = "oracle_from_physical_standby_vdb";
  @SerializedName(SERIALIZED_NAME_ORACLE_FROM_PHYSICAL_STANDBY_VDB)
  private Boolean oracleFromPhysicalStandbyVdb;

  public static final String SERIALIZED_NAME_ORACLE_REDO_LOG_SIZE_IN_BYTES = "oracle_redo_log_size_in_bytes";
  @SerializedName(SERIALIZED_NAME_ORACLE_REDO_LOG_SIZE_IN_BYTES)
  private Long oracleRedoLogSizeInBytes;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<Tag> tags = null;


  public Snapshot id(String id) {
    
    this.id = id;
    return this;
  }

   /**
   * The Snapshot ID.
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "snapshot-123", value = "The Snapshot ID.")

  public String getId() {
    return id;
  }


  public void setId(String id) {
    this.id = id;
  }


  public Snapshot engineId(String engineId) {
    
    this.engineId = engineId;
    return this;
  }

   /**
   * The id of the engine the snapshot belongs to.
   * @return engineId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "1", value = "The id of the engine the snapshot belongs to.")

  public String getEngineId() {
    return engineId;
  }


  public void setEngineId(String engineId) {
    this.engineId = engineId;
  }


  public Snapshot namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * Alternate namespace for this object, for replicated and restored snapshots.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "NAMESPACE-1", value = "Alternate namespace for this object, for replicated and restored snapshots.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public Snapshot name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The snapshot&#39;s name.
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "@2023-02-02T14:30:00.589", value = "The snapshot's name.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public Snapshot consistency(ConsistencyEnum consistency) {
    
    this.consistency = consistency;
    return this;
  }

   /**
   * Indicates what type of recovery strategies must be invoked when provisioning from this snapshot.
   * @return consistency
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "CONSISTENT", value = "Indicates what type of recovery strategies must be invoked when provisioning from this snapshot.")

  public ConsistencyEnum getConsistency() {
    return consistency;
  }


  public void setConsistency(ConsistencyEnum consistency) {
    this.consistency = consistency;
  }


  public Snapshot missingNonLoggedData(Boolean missingNonLoggedData) {
    
    this.missingNonLoggedData = missingNonLoggedData;
    return this;
  }

   /**
   * Indicates if a virtual database provisioned from this snapshot will be missing nologging changes.
   * @return missingNonLoggedData
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Indicates if a virtual database provisioned from this snapshot will be missing nologging changes.")

  public Boolean getMissingNonLoggedData() {
    return missingNonLoggedData;
  }


  public void setMissingNonLoggedData(Boolean missingNonLoggedData) {
    this.missingNonLoggedData = missingNonLoggedData;
  }


  public Snapshot datasetId(String datasetId) {
    
    this.datasetId = datasetId;
    return this;
  }

   /**
   * The ID of the Snapshot&#39;s dSource or VDB.
   * @return datasetId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "dataset-123", value = "The ID of the Snapshot's dSource or VDB.")

  public String getDatasetId() {
    return datasetId;
  }


  public void setDatasetId(String datasetId) {
    this.datasetId = datasetId;
  }


  public Snapshot creationTime(OffsetDateTime creationTime) {
    
    this.creationTime = creationTime;
    return this;
  }

   /**
   * The time when the snapshot was created.
   * @return creationTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2023-02-02T19:30:00.589Z", value = "The time when the snapshot was created.")

  public OffsetDateTime getCreationTime() {
    return creationTime;
  }


  public void setCreationTime(OffsetDateTime creationTime) {
    this.creationTime = creationTime;
  }


  public Snapshot startTimestamp(OffsetDateTime startTimestamp) {
    
    this.startTimestamp = startTimestamp;
    return this;
  }

   /**
   * The timestamp within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_timestamp equals timestamp, then no recovery needs to be \\ applied in order to provision a database. 
   * @return startTimestamp
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2021-05-01T08:51:34.148Z", value = "The timestamp within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_timestamp equals timestamp, then no recovery needs to be \\ applied in order to provision a database. ")

  public OffsetDateTime getStartTimestamp() {
    return startTimestamp;
  }


  public void setStartTimestamp(OffsetDateTime startTimestamp) {
    this.startTimestamp = startTimestamp;
  }


  public Snapshot startLocation(String startLocation) {
    
    this.startLocation = startLocation;
    return this;
  }

   /**
   * The database specific indentifier within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_location equals location, then no recovery needs to be \\ applied in order to provision a database. 
   * @return startLocation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "1178883", value = "The database specific indentifier within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_location equals location, then no recovery needs to be \\ applied in order to provision a database. ")

  public String getStartLocation() {
    return startLocation;
  }


  public void setStartLocation(String startLocation) {
    this.startLocation = startLocation;
  }


  public Snapshot timestamp(OffsetDateTime timestamp) {
    
    this.timestamp = timestamp;
    return this;
  }

   /**
   * The logical time of the data contained in this Snapshot.
   * @return timestamp
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2021-05-01T08:51:34.148Z", value = "The logical time of the data contained in this Snapshot.")

  public OffsetDateTime getTimestamp() {
    return timestamp;
  }


  public void setTimestamp(OffsetDateTime timestamp) {
    this.timestamp = timestamp;
  }


  public Snapshot location(String location) {
    
    this.location = location;
    return this;
  }

   /**
   * Database specific identifier for the data contained in this Snapshot, such as the Log Sequence Number (LSN) for MSsql databases, System Change Number (SCN) for Oracle databases.
   * @return location
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "1178883", value = "Database specific identifier for the data contained in this Snapshot, such as the Log Sequence Number (LSN) for MSsql databases, System Change Number (SCN) for Oracle databases.")

  public String getLocation() {
    return location;
  }


  public void setLocation(String location) {
    this.location = location;
  }


  public Snapshot retention(Long retention) {
    
    this.retention = retention;
    return this;
  }

   /**
   * Retention policy, in days. A value of -1 indicates the snapshot should be kept forever. Deprecated in favor of expiration and retain_forever.
   * @return retention
   * @deprecated
  **/
  @Deprecated
  @javax.annotation.Nullable
  @ApiModelProperty(example = "-1", value = "Retention policy, in days. A value of -1 indicates the snapshot should be kept forever. Deprecated in favor of expiration and retain_forever.")

  public Long getRetention() {
    return retention;
  }


  public void setRetention(Long retention) {
    this.retention = retention;
  }


  public Snapshot expiration(LocalDate expiration) {
    
    this.expiration = expiration;
    return this;
  }

   /**
   * The expiration date of this snapshot. If this is unset and retain_forever is false, and the snapshot is not included in a Bookmark, the snapshot is subject to the retention policy of its dataset.
   * @return expiration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Sun Jul 04 05:30:00 IST 2021", value = "The expiration date of this snapshot. If this is unset and retain_forever is false, and the snapshot is not included in a Bookmark, the snapshot is subject to the retention policy of its dataset.")

  public LocalDate getExpiration() {
    return expiration;
  }


  public void setExpiration(LocalDate expiration) {
    this.expiration = expiration;
  }


  public Snapshot retainForever(Boolean retainForever) {
    
    this.retainForever = retainForever;
    return this;
  }

   /**
   * Indicates that the snapshot is protected from retention, i.e it will be kept forever. If false, see expiration.
   * @return retainForever
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Indicates that the snapshot is protected from retention, i.e it will be kept forever. If false, see expiration.")

  public Boolean getRetainForever() {
    return retainForever;
  }


  public void setRetainForever(Boolean retainForever) {
    this.retainForever = retainForever;
  }


  public Snapshot effectiveExpiration(LocalDate effectiveExpiration) {
    
    this.effectiveExpiration = effectiveExpiration;
    return this;
  }

   /**
   * The effective expiration is that max of the snapshot expiration and the expiration of any Bookmark which includes this snapshot.
   * @return effectiveExpiration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "Sun Jul 04 05:30:00 IST 2021", value = "The effective expiration is that max of the snapshot expiration and the expiration of any Bookmark which includes this snapshot.")

  public LocalDate getEffectiveExpiration() {
    return effectiveExpiration;
  }


  public void setEffectiveExpiration(LocalDate effectiveExpiration) {
    this.effectiveExpiration = effectiveExpiration;
  }


  public Snapshot effectiveRetainForever(Boolean effectiveRetainForever) {
    
    this.effectiveRetainForever = effectiveRetainForever;
    return this;
  }

   /**
   * True if retain_forever is set or a Bookmark retains this snapshot forever.
   * @return effectiveRetainForever
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "True if retain_forever is set or a Bookmark retains this snapshot forever.")

  public Boolean getEffectiveRetainForever() {
    return effectiveRetainForever;
  }


  public void setEffectiveRetainForever(Boolean effectiveRetainForever) {
    this.effectiveRetainForever = effectiveRetainForever;
  }


  public Snapshot timeflowId(String timeflowId) {
    
    this.timeflowId = timeflowId;
    return this;
  }

   /**
   * The TimeFlow this snapshot was taken on.
   * @return timeflowId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "1-ORACLE_TIMEFLOW-1", value = "The TimeFlow this snapshot was taken on.")

  public String getTimeflowId() {
    return timeflowId;
  }


  public void setTimeflowId(String timeflowId) {
    this.timeflowId = timeflowId;
  }


  public Snapshot timezone(String timezone) {
    
    this.timezone = timezone;
    return this;
  }

   /**
   * Time zone of the source database at the time the snapshot was taken.
   * @return timezone
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "America/New_York,EST-0500", value = "Time zone of the source database at the time the snapshot was taken.")

  public String getTimezone() {
    return timezone;
  }


  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public Snapshot version(String version) {
    
    this.version = version;
    return this;
  }

   /**
   * Version of database source repository at the time the snapshot was taken.
   * @return version
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "11.2.0.4.0", value = "Version of database source repository at the time the snapshot was taken.")

  public String getVersion() {
    return version;
  }


  public void setVersion(String version) {
    this.version = version;
  }


  public Snapshot temporary(Boolean temporary) {
    
    this.temporary = temporary;
    return this;
  }

   /**
   * Indicates that this snapshot is in a transient state and should not be user visible.
   * @return temporary
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "Indicates that this snapshot is in a transient state and should not be user visible.")

  public Boolean getTemporary() {
    return temporary;
  }


  public void setTemporary(Boolean temporary) {
    this.temporary = temporary;
  }


  public Snapshot appdataToolkit(String appdataToolkit) {
    
    this.appdataToolkit = appdataToolkit;
    return this;
  }

   /**
   * The toolkit associated with this snapshot.
   * @return appdataToolkit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "APPDATA_TOOLKIT-1", value = "The toolkit associated with this snapshot.")

  public String getAppdataToolkit() {
    return appdataToolkit;
  }


  public void setAppdataToolkit(String appdataToolkit) {
    this.appdataToolkit = appdataToolkit;
  }


  public Snapshot appdataMetadata(String appdataMetadata) {
    
    this.appdataMetadata = appdataMetadata;
    return this;
  }

   /**
   * The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated.
   * @return appdataMetadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "{}", value = "The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated.")

  public String getAppdataMetadata() {
    return appdataMetadata;
  }


  public void setAppdataMetadata(String appdataMetadata) {
    this.appdataMetadata = appdataMetadata;
  }


  public Snapshot aseDbEncryptionKey(String aseDbEncryptionKey) {
    
    this.aseDbEncryptionKey = aseDbEncryptionKey;
    return this;
  }

   /**
   * Database encryption key present for this snapshot.
   * @return aseDbEncryptionKey
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "keyname", value = "Database encryption key present for this snapshot.")

  public String getAseDbEncryptionKey() {
    return aseDbEncryptionKey;
  }


  public void setAseDbEncryptionKey(String aseDbEncryptionKey) {
    this.aseDbEncryptionKey = aseDbEncryptionKey;
  }


  public Snapshot mssqlInternalVersion(Integer mssqlInternalVersion) {
    
    this.mssqlInternalVersion = mssqlInternalVersion;
    return this;
  }

   /**
   * Internal version of the source database at the time the snapshot was taken.
   * @return mssqlInternalVersion
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "706", value = "Internal version of the source database at the time the snapshot was taken.")

  public Integer getMssqlInternalVersion() {
    return mssqlInternalVersion;
  }


  public void setMssqlInternalVersion(Integer mssqlInternalVersion) {
    this.mssqlInternalVersion = mssqlInternalVersion;
  }


  public Snapshot mssqlBackupSetUuid(String mssqlBackupSetUuid) {
    
    this.mssqlBackupSetUuid = mssqlBackupSetUuid;
    return this;
  }

   /**
   * UUID of the source database backup that was restored for this snapshot.
   * @return mssqlBackupSetUuid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "54290b71-58cd-463d-bd62-7219d4c4d2d5", value = "UUID of the source database backup that was restored for this snapshot.")

  public String getMssqlBackupSetUuid() {
    return mssqlBackupSetUuid;
  }


  public void setMssqlBackupSetUuid(String mssqlBackupSetUuid) {
    this.mssqlBackupSetUuid = mssqlBackupSetUuid;
  }


  public Snapshot mssqlBackupSoftwareType(MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType) {
    
    this.mssqlBackupSoftwareType = mssqlBackupSoftwareType;
    return this;
  }

   /**
   * Backup software used to restore the source database backup for this snapshot
   * @return mssqlBackupSoftwareType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "NATIVE", value = "Backup software used to restore the source database backup for this snapshot")

  public MssqlBackupSoftwareTypeEnum getMssqlBackupSoftwareType() {
    return mssqlBackupSoftwareType;
  }


  public void setMssqlBackupSoftwareType(MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType) {
    this.mssqlBackupSoftwareType = mssqlBackupSoftwareType;
  }


  public Snapshot mssqlBackupLocationType(MssqlBackupLocationTypeEnum mssqlBackupLocationType) {
    
    this.mssqlBackupLocationType = mssqlBackupLocationType;
    return this;
  }

   /**
   * Backup software used to restore the source database backup for this snapshot
   * @return mssqlBackupLocationType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "BACKUP_SERVER", value = "Backup software used to restore the source database backup for this snapshot")

  public MssqlBackupLocationTypeEnum getMssqlBackupLocationType() {
    return mssqlBackupLocationType;
  }


  public void setMssqlBackupLocationType(MssqlBackupLocationTypeEnum mssqlBackupLocationType) {
    this.mssqlBackupLocationType = mssqlBackupLocationType;
  }


  public Snapshot mssqlEmptySnapshot(Boolean mssqlEmptySnapshot) {
    
    this.mssqlEmptySnapshot = mssqlEmptySnapshot;
    return this;
  }

   /**
   * True if the staging push dSource snapshot is empty.
   * @return mssqlEmptySnapshot
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "true", value = "True if the staging push dSource snapshot is empty.")

  public Boolean getMssqlEmptySnapshot() {
    return mssqlEmptySnapshot;
  }


  public void setMssqlEmptySnapshot(Boolean mssqlEmptySnapshot) {
    this.mssqlEmptySnapshot = mssqlEmptySnapshot;
  }


  public Snapshot oracleFromPhysicalStandbyVdb(Boolean oracleFromPhysicalStandbyVdb) {
    
    this.oracleFromPhysicalStandbyVdb = oracleFromPhysicalStandbyVdb;
    return this;
  }

   /**
   * True if this snapshot was taken of a standby database.
   * @return oracleFromPhysicalStandbyVdb
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "false", value = "True if this snapshot was taken of a standby database.")

  public Boolean getOracleFromPhysicalStandbyVdb() {
    return oracleFromPhysicalStandbyVdb;
  }


  public void setOracleFromPhysicalStandbyVdb(Boolean oracleFromPhysicalStandbyVdb) {
    this.oracleFromPhysicalStandbyVdb = oracleFromPhysicalStandbyVdb;
  }


  public Snapshot oracleRedoLogSizeInBytes(Long oracleRedoLogSizeInBytes) {
    
    this.oracleRedoLogSizeInBytes = oracleRedoLogSizeInBytes;
    return this;
  }

   /**
   * Online redo log size in bytes when this snapshot was taken.
   * @return oracleRedoLogSizeInBytes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "314572800", value = "Online redo log size in bytes when this snapshot was taken.")

  public Long getOracleRedoLogSizeInBytes() {
    return oracleRedoLogSizeInBytes;
  }


  public void setOracleRedoLogSizeInBytes(Long oracleRedoLogSizeInBytes) {
    this.oracleRedoLogSizeInBytes = oracleRedoLogSizeInBytes;
  }


  public Snapshot tags(List<Tag> tags) {
    
    this.tags = tags;
    return this;
  }

  public Snapshot addTagsItem(Tag tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<Tag>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * Get tags
   * @return tags
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public List<Tag> getTags() {
    return tags;
  }


  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Snapshot snapshot = (Snapshot) o;
    return Objects.equals(this.id, snapshot.id) &&
        Objects.equals(this.engineId, snapshot.engineId) &&
        Objects.equals(this.namespace, snapshot.namespace) &&
        Objects.equals(this.name, snapshot.name) &&
        Objects.equals(this.consistency, snapshot.consistency) &&
        Objects.equals(this.missingNonLoggedData, snapshot.missingNonLoggedData) &&
        Objects.equals(this.datasetId, snapshot.datasetId) &&
        Objects.equals(this.creationTime, snapshot.creationTime) &&
        Objects.equals(this.startTimestamp, snapshot.startTimestamp) &&
        Objects.equals(this.startLocation, snapshot.startLocation) &&
        Objects.equals(this.timestamp, snapshot.timestamp) &&
        Objects.equals(this.location, snapshot.location) &&
        Objects.equals(this.retention, snapshot.retention) &&
        Objects.equals(this.expiration, snapshot.expiration) &&
        Objects.equals(this.retainForever, snapshot.retainForever) &&
        Objects.equals(this.effectiveExpiration, snapshot.effectiveExpiration) &&
        Objects.equals(this.effectiveRetainForever, snapshot.effectiveRetainForever) &&
        Objects.equals(this.timeflowId, snapshot.timeflowId) &&
        Objects.equals(this.timezone, snapshot.timezone) &&
        Objects.equals(this.version, snapshot.version) &&
        Objects.equals(this.temporary, snapshot.temporary) &&
        Objects.equals(this.appdataToolkit, snapshot.appdataToolkit) &&
        Objects.equals(this.appdataMetadata, snapshot.appdataMetadata) &&
        Objects.equals(this.aseDbEncryptionKey, snapshot.aseDbEncryptionKey) &&
        Objects.equals(this.mssqlInternalVersion, snapshot.mssqlInternalVersion) &&
        Objects.equals(this.mssqlBackupSetUuid, snapshot.mssqlBackupSetUuid) &&
        Objects.equals(this.mssqlBackupSoftwareType, snapshot.mssqlBackupSoftwareType) &&
        Objects.equals(this.mssqlBackupLocationType, snapshot.mssqlBackupLocationType) &&
        Objects.equals(this.mssqlEmptySnapshot, snapshot.mssqlEmptySnapshot) &&
        Objects.equals(this.oracleFromPhysicalStandbyVdb, snapshot.oracleFromPhysicalStandbyVdb) &&
        Objects.equals(this.oracleRedoLogSizeInBytes, snapshot.oracleRedoLogSizeInBytes) &&
        Objects.equals(this.tags, snapshot.tags);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && a.get().getClass().isArray() ? Arrays.equals((T[])a.get(), (T[])b.get()) : Objects.equals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, engineId, namespace, name, consistency, missingNonLoggedData, datasetId, creationTime, startTimestamp, startLocation, timestamp, location, retention, expiration, retainForever, effectiveExpiration, effectiveRetainForever, timeflowId, timezone, version, temporary, appdataToolkit, appdataMetadata, aseDbEncryptionKey, mssqlInternalVersion, mssqlBackupSetUuid, mssqlBackupSoftwareType, mssqlBackupLocationType, mssqlEmptySnapshot, oracleFromPhysicalStandbyVdb, oracleRedoLogSizeInBytes, tags);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent()
      ? (a.get().getClass().isArray() ? Arrays.hashCode((T[])a.get()) : Objects.hashCode(a.get()))
      : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Snapshot {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    engineId: ").append(toIndentedString(engineId)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    consistency: ").append(toIndentedString(consistency)).append("\n");
    sb.append("    missingNonLoggedData: ").append(toIndentedString(missingNonLoggedData)).append("\n");
    sb.append("    datasetId: ").append(toIndentedString(datasetId)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    startTimestamp: ").append(toIndentedString(startTimestamp)).append("\n");
    sb.append("    startLocation: ").append(toIndentedString(startLocation)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    retention: ").append(toIndentedString(retention)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    retainForever: ").append(toIndentedString(retainForever)).append("\n");
    sb.append("    effectiveExpiration: ").append(toIndentedString(effectiveExpiration)).append("\n");
    sb.append("    effectiveRetainForever: ").append(toIndentedString(effectiveRetainForever)).append("\n");
    sb.append("    timeflowId: ").append(toIndentedString(timeflowId)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    temporary: ").append(toIndentedString(temporary)).append("\n");
    sb.append("    appdataToolkit: ").append(toIndentedString(appdataToolkit)).append("\n");
    sb.append("    appdataMetadata: ").append(toIndentedString(appdataMetadata)).append("\n");
    sb.append("    aseDbEncryptionKey: ").append(toIndentedString(aseDbEncryptionKey)).append("\n");
    sb.append("    mssqlInternalVersion: ").append(toIndentedString(mssqlInternalVersion)).append("\n");
    sb.append("    mssqlBackupSetUuid: ").append(toIndentedString(mssqlBackupSetUuid)).append("\n");
    sb.append("    mssqlBackupSoftwareType: ").append(toIndentedString(mssqlBackupSoftwareType)).append("\n");
    sb.append("    mssqlBackupLocationType: ").append(toIndentedString(mssqlBackupLocationType)).append("\n");
    sb.append("    mssqlEmptySnapshot: ").append(toIndentedString(mssqlEmptySnapshot)).append("\n");
    sb.append("    oracleFromPhysicalStandbyVdb: ").append(toIndentedString(oracleFromPhysicalStandbyVdb)).append("\n");
    sb.append("    oracleRedoLogSizeInBytes: ").append(toIndentedString(oracleRedoLogSizeInBytes)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

