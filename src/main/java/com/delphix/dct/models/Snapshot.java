/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.10.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.models;

import java.util.Objects;
import com.delphix.dct.models.Tag;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.delphix.dct.JSON;

/**
 * Virtualization Engine Snapshot of a dSource or VDB.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-04T14:49:34.152994+05:30[Asia/Kolkata]", comments = "Generator version: 7.4.0")
public class Snapshot {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_ENGINE_ID = "engine_id";
  @SerializedName(SERIALIZED_NAME_ENGINE_ID)
  private String engineId;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE_ID = "namespace_id";
  @SerializedName(SERIALIZED_NAME_NAMESPACE_ID)
  private String namespaceId;

  public static final String SERIALIZED_NAME_NAMESPACE_NAME = "namespace_name";
  @SerializedName(SERIALIZED_NAME_NAMESPACE_NAME)
  private String namespaceName;

  public static final String SERIALIZED_NAME_IS_REPLICA = "is_replica";
  @SerializedName(SERIALIZED_NAME_IS_REPLICA)
  private Boolean isReplica;

  /**
   * Indicates what type of recovery strategies must be invoked when provisioning from this snapshot.
   */
  @JsonAdapter(ConsistencyEnum.Adapter.class)
  public enum ConsistencyEnum {
    CONSISTENT("CONSISTENT"),
    
    INCONSISTENT("INCONSISTENT"),
    
    CRASH_CONSISTENT("CRASH_CONSISTENT"),
    
    PLUGGABLE("PLUGGABLE");

    private String value;

    ConsistencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConsistencyEnum fromValue(String value) {
      for (ConsistencyEnum b : ConsistencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ConsistencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConsistencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConsistencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ConsistencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ConsistencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONSISTENCY = "consistency";
  @SerializedName(SERIALIZED_NAME_CONSISTENCY)
  private ConsistencyEnum consistency;

  public static final String SERIALIZED_NAME_MISSING_NON_LOGGED_DATA = "missing_non_logged_data";
  @SerializedName(SERIALIZED_NAME_MISSING_NON_LOGGED_DATA)
  private Boolean missingNonLoggedData;

  public static final String SERIALIZED_NAME_DATASET_ID = "dataset_id";
  @SerializedName(SERIALIZED_NAME_DATASET_ID)
  private String datasetId;

  public static final String SERIALIZED_NAME_CREATION_TIME = "creation_time";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private OffsetDateTime creationTime;

  public static final String SERIALIZED_NAME_START_TIMESTAMP = "start_timestamp";
  @SerializedName(SERIALIZED_NAME_START_TIMESTAMP)
  private OffsetDateTime startTimestamp;

  public static final String SERIALIZED_NAME_START_LOCATION = "start_location";
  @SerializedName(SERIALIZED_NAME_START_LOCATION)
  private String startLocation;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private OffsetDateTime timestamp;

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_RETENTION = "retention";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_RETENTION)
  private Long retention;

  public static final String SERIALIZED_NAME_EXPIRATION = "expiration";
  @SerializedName(SERIALIZED_NAME_EXPIRATION)
  private LocalDate expiration;

  public static final String SERIALIZED_NAME_RETAIN_FOREVER = "retain_forever";
  @SerializedName(SERIALIZED_NAME_RETAIN_FOREVER)
  private Boolean retainForever;

  public static final String SERIALIZED_NAME_EFFECTIVE_EXPIRATION = "effective_expiration";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_EXPIRATION)
  private LocalDate effectiveExpiration;

  public static final String SERIALIZED_NAME_EFFECTIVE_RETAIN_FOREVER = "effective_retain_forever";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_RETAIN_FOREVER)
  private Boolean effectiveRetainForever;

  public static final String SERIALIZED_NAME_TIMEFLOW_ID = "timeflow_id";
  @SerializedName(SERIALIZED_NAME_TIMEFLOW_ID)
  private String timeflowId;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  private String timezone;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_TEMPORARY = "temporary";
  @SerializedName(SERIALIZED_NAME_TEMPORARY)
  private Boolean temporary;

  public static final String SERIALIZED_NAME_APPDATA_TOOLKIT = "appdata_toolkit";
  @SerializedName(SERIALIZED_NAME_APPDATA_TOOLKIT)
  private String appdataToolkit;

  public static final String SERIALIZED_NAME_APPDATA_METADATA = "appdata_metadata";
  @SerializedName(SERIALIZED_NAME_APPDATA_METADATA)
  private String appdataMetadata;

  public static final String SERIALIZED_NAME_ASE_DB_ENCRYPTION_KEY = "ase_db_encryption_key";
  @SerializedName(SERIALIZED_NAME_ASE_DB_ENCRYPTION_KEY)
  private String aseDbEncryptionKey;

  public static final String SERIALIZED_NAME_MSSQL_INTERNAL_VERSION = "mssql_internal_version";
  @SerializedName(SERIALIZED_NAME_MSSQL_INTERNAL_VERSION)
  private Integer mssqlInternalVersion;

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_SET_UUID = "mssql_backup_set_uuid";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_SET_UUID)
  private String mssqlBackupSetUuid;

  /**
   * Backup software used to restore the source database backup for this snapshot
   */
  @JsonAdapter(MssqlBackupSoftwareTypeEnum.Adapter.class)
  public enum MssqlBackupSoftwareTypeEnum {
    AZURE_NATIVE("AZURE_NATIVE"),
    
    NATIVE("NATIVE"),
    
    LITESPEED("LITESPEED"),
    
    REDGATE("REDGATE"),
    
    NETBACKUP("NETBACKUP"),
    
    COMMVAULT("COMMVAULT");

    private String value;

    MssqlBackupSoftwareTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MssqlBackupSoftwareTypeEnum fromValue(String value) {
      for (MssqlBackupSoftwareTypeEnum b : MssqlBackupSoftwareTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MssqlBackupSoftwareTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MssqlBackupSoftwareTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MssqlBackupSoftwareTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MssqlBackupSoftwareTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MssqlBackupSoftwareTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_SOFTWARE_TYPE = "mssql_backup_software_type";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_SOFTWARE_TYPE)
  private MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType;

  /**
   * Backup software used to restore the source database backup for this snapshot
   */
  @JsonAdapter(MssqlBackupLocationTypeEnum.Adapter.class)
  public enum MssqlBackupLocationTypeEnum {
    DISK("DISK"),
    
    AZURE("AZURE"),
    
    BACKUP_SERVER("BACKUP_SERVER");

    private String value;

    MssqlBackupLocationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MssqlBackupLocationTypeEnum fromValue(String value) {
      for (MssqlBackupLocationTypeEnum b : MssqlBackupLocationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MssqlBackupLocationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MssqlBackupLocationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MssqlBackupLocationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MssqlBackupLocationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MssqlBackupLocationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_LOCATION_TYPE = "mssql_backup_location_type";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_LOCATION_TYPE)
  private MssqlBackupLocationTypeEnum mssqlBackupLocationType;

  public static final String SERIALIZED_NAME_MSSQL_EMPTY_SNAPSHOT = "mssql_empty_snapshot";
  @SerializedName(SERIALIZED_NAME_MSSQL_EMPTY_SNAPSHOT)
  private Boolean mssqlEmptySnapshot;

  public static final String SERIALIZED_NAME_ORACLE_FROM_PHYSICAL_STANDBY_VDB = "oracle_from_physical_standby_vdb";
  @SerializedName(SERIALIZED_NAME_ORACLE_FROM_PHYSICAL_STANDBY_VDB)
  private Boolean oracleFromPhysicalStandbyVdb;

  public static final String SERIALIZED_NAME_ORACLE_REDO_LOG_SIZE_IN_BYTES = "oracle_redo_log_size_in_bytes";
  @SerializedName(SERIALIZED_NAME_ORACLE_REDO_LOG_SIZE_IN_BYTES)
  private Long oracleRedoLogSizeInBytes;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<Tag> tags;

  public Snapshot() {
  }

  public Snapshot id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The Snapshot ID.
   * @return id
  **/
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Snapshot engineId(String engineId) {
    this.engineId = engineId;
    return this;
  }

   /**
   * The id of the engine the snapshot belongs to.
   * @return engineId
  **/
  @javax.annotation.Nullable
  public String getEngineId() {
    return engineId;
  }

  public void setEngineId(String engineId) {
    this.engineId = engineId;
  }


  public Snapshot namespace(String namespace) {
    this.namespace = namespace;
    return this;
  }

   /**
   * Alternate namespace for this object, for replicated and restored snapshots.
   * @return namespace
  **/
  @javax.annotation.Nullable
  public String getNamespace() {
    return namespace;
  }

  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public Snapshot name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The snapshot&#39;s name.
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Snapshot namespaceId(String namespaceId) {
    this.namespaceId = namespaceId;
    return this;
  }

   /**
   * The namespace id of this snapshot.
   * @return namespaceId
  **/
  @javax.annotation.Nullable
  public String getNamespaceId() {
    return namespaceId;
  }

  public void setNamespaceId(String namespaceId) {
    this.namespaceId = namespaceId;
  }


  public Snapshot namespaceName(String namespaceName) {
    this.namespaceName = namespaceName;
    return this;
  }

   /**
   * The namespace name of this snapshot.
   * @return namespaceName
  **/
  @javax.annotation.Nullable
  public String getNamespaceName() {
    return namespaceName;
  }

  public void setNamespaceName(String namespaceName) {
    this.namespaceName = namespaceName;
  }


  public Snapshot isReplica(Boolean isReplica) {
    this.isReplica = isReplica;
    return this;
  }

   /**
   * Is this a replicated object.
   * @return isReplica
  **/
  @javax.annotation.Nullable
  public Boolean getIsReplica() {
    return isReplica;
  }

  public void setIsReplica(Boolean isReplica) {
    this.isReplica = isReplica;
  }


  public Snapshot consistency(ConsistencyEnum consistency) {
    this.consistency = consistency;
    return this;
  }

   /**
   * Indicates what type of recovery strategies must be invoked when provisioning from this snapshot.
   * @return consistency
  **/
  @javax.annotation.Nullable
  public ConsistencyEnum getConsistency() {
    return consistency;
  }

  public void setConsistency(ConsistencyEnum consistency) {
    this.consistency = consistency;
  }


  public Snapshot missingNonLoggedData(Boolean missingNonLoggedData) {
    this.missingNonLoggedData = missingNonLoggedData;
    return this;
  }

   /**
   * Indicates if a virtual database provisioned from this snapshot will be missing nologging changes.
   * @return missingNonLoggedData
  **/
  @javax.annotation.Nullable
  public Boolean getMissingNonLoggedData() {
    return missingNonLoggedData;
  }

  public void setMissingNonLoggedData(Boolean missingNonLoggedData) {
    this.missingNonLoggedData = missingNonLoggedData;
  }


  public Snapshot datasetId(String datasetId) {
    this.datasetId = datasetId;
    return this;
  }

   /**
   * The ID of the Snapshot&#39;s dSource or VDB.
   * @return datasetId
  **/
  @javax.annotation.Nullable
  public String getDatasetId() {
    return datasetId;
  }

  public void setDatasetId(String datasetId) {
    this.datasetId = datasetId;
  }


  public Snapshot creationTime(OffsetDateTime creationTime) {
    this.creationTime = creationTime;
    return this;
  }

   /**
   * The time when the snapshot was created.
   * @return creationTime
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCreationTime() {
    return creationTime;
  }

  public void setCreationTime(OffsetDateTime creationTime) {
    this.creationTime = creationTime;
  }


  public Snapshot startTimestamp(OffsetDateTime startTimestamp) {
    this.startTimestamp = startTimestamp;
    return this;
  }

   /**
   * The timestamp within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_timestamp equals timestamp, then no recovery needs to be \\ applied in order to provision a database. 
   * @return startTimestamp
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getStartTimestamp() {
    return startTimestamp;
  }

  public void setStartTimestamp(OffsetDateTime startTimestamp) {
    this.startTimestamp = startTimestamp;
  }


  public Snapshot startLocation(String startLocation) {
    this.startLocation = startLocation;
    return this;
  }

   /**
   * The database specific indentifier within the parent TimeFlow at which this snapshot was initiated. \\ No recovery earlier than this point needs to be applied in order to provision a database from \\ this snapshot. If start_location equals location, then no recovery needs to be \\ applied in order to provision a database. 
   * @return startLocation
  **/
  @javax.annotation.Nullable
  public String getStartLocation() {
    return startLocation;
  }

  public void setStartLocation(String startLocation) {
    this.startLocation = startLocation;
  }


  public Snapshot timestamp(OffsetDateTime timestamp) {
    this.timestamp = timestamp;
    return this;
  }

   /**
   * The logical time of the data contained in this Snapshot.
   * @return timestamp
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(OffsetDateTime timestamp) {
    this.timestamp = timestamp;
  }


  public Snapshot location(String location) {
    this.location = location;
    return this;
  }

   /**
   * Database specific identifier for the data contained in this Snapshot, such as the Log Sequence Number (LSN) for MSsql databases, System Change Number (SCN) for Oracle databases.
   * @return location
  **/
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  @Deprecated
  public Snapshot retention(Long retention) {
    this.retention = retention;
    return this;
  }

   /**
   * Retention policy, in days. A value of -1 indicates the snapshot should be kept forever. Deprecated in favor of expiration and retain_forever.
   * @return retention
   * @deprecated
  **/
  @Deprecated
  @javax.annotation.Nullable
  public Long getRetention() {
    return retention;
  }

  @Deprecated
  public void setRetention(Long retention) {
    this.retention = retention;
  }


  public Snapshot expiration(LocalDate expiration) {
    this.expiration = expiration;
    return this;
  }

   /**
   * The expiration date of this snapshot. If this is unset and retain_forever is false, and the snapshot is not included in a Bookmark, the snapshot is subject to the retention policy of its dataset.
   * @return expiration
  **/
  @javax.annotation.Nullable
  public LocalDate getExpiration() {
    return expiration;
  }

  public void setExpiration(LocalDate expiration) {
    this.expiration = expiration;
  }


  public Snapshot retainForever(Boolean retainForever) {
    this.retainForever = retainForever;
    return this;
  }

   /**
   * Indicates that the snapshot is protected from retention, i.e it will be kept forever. If false, see expiration.
   * @return retainForever
  **/
  @javax.annotation.Nullable
  public Boolean getRetainForever() {
    return retainForever;
  }

  public void setRetainForever(Boolean retainForever) {
    this.retainForever = retainForever;
  }


  public Snapshot effectiveExpiration(LocalDate effectiveExpiration) {
    this.effectiveExpiration = effectiveExpiration;
    return this;
  }

   /**
   * The effective expiration is that max of the snapshot expiration and the expiration of any Bookmark which includes this snapshot.
   * @return effectiveExpiration
  **/
  @javax.annotation.Nullable
  public LocalDate getEffectiveExpiration() {
    return effectiveExpiration;
  }

  public void setEffectiveExpiration(LocalDate effectiveExpiration) {
    this.effectiveExpiration = effectiveExpiration;
  }


  public Snapshot effectiveRetainForever(Boolean effectiveRetainForever) {
    this.effectiveRetainForever = effectiveRetainForever;
    return this;
  }

   /**
   * True if retain_forever is set or a Bookmark retains this snapshot forever.
   * @return effectiveRetainForever
  **/
  @javax.annotation.Nullable
  public Boolean getEffectiveRetainForever() {
    return effectiveRetainForever;
  }

  public void setEffectiveRetainForever(Boolean effectiveRetainForever) {
    this.effectiveRetainForever = effectiveRetainForever;
  }


  public Snapshot timeflowId(String timeflowId) {
    this.timeflowId = timeflowId;
    return this;
  }

   /**
   * The TimeFlow this snapshot was taken on.
   * @return timeflowId
  **/
  @javax.annotation.Nullable
  public String getTimeflowId() {
    return timeflowId;
  }

  public void setTimeflowId(String timeflowId) {
    this.timeflowId = timeflowId;
  }


  public Snapshot timezone(String timezone) {
    this.timezone = timezone;
    return this;
  }

   /**
   * Time zone of the source database at the time the snapshot was taken.
   * @return timezone
  **/
  @javax.annotation.Nullable
  public String getTimezone() {
    return timezone;
  }

  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public Snapshot version(String version) {
    this.version = version;
    return this;
  }

   /**
   * Version of database source repository at the time the snapshot was taken.
   * @return version
  **/
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }


  public Snapshot temporary(Boolean temporary) {
    this.temporary = temporary;
    return this;
  }

   /**
   * Indicates that this snapshot is in a transient state and should not be user visible.
   * @return temporary
  **/
  @javax.annotation.Nullable
  public Boolean getTemporary() {
    return temporary;
  }

  public void setTemporary(Boolean temporary) {
    this.temporary = temporary;
  }


  public Snapshot appdataToolkit(String appdataToolkit) {
    this.appdataToolkit = appdataToolkit;
    return this;
  }

   /**
   * The toolkit associated with this snapshot.
   * @return appdataToolkit
  **/
  @javax.annotation.Nullable
  public String getAppdataToolkit() {
    return appdataToolkit;
  }

  public void setAppdataToolkit(String appdataToolkit) {
    this.appdataToolkit = appdataToolkit;
  }


  public Snapshot appdataMetadata(String appdataMetadata) {
    this.appdataMetadata = appdataMetadata;
    return this;
  }

   /**
   * The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated.
   * @return appdataMetadata
  **/
  @javax.annotation.Nullable
  public String getAppdataMetadata() {
    return appdataMetadata;
  }

  public void setAppdataMetadata(String appdataMetadata) {
    this.appdataMetadata = appdataMetadata;
  }


  public Snapshot aseDbEncryptionKey(String aseDbEncryptionKey) {
    this.aseDbEncryptionKey = aseDbEncryptionKey;
    return this;
  }

   /**
   * Database encryption key present for this snapshot.
   * @return aseDbEncryptionKey
  **/
  @javax.annotation.Nullable
  public String getAseDbEncryptionKey() {
    return aseDbEncryptionKey;
  }

  public void setAseDbEncryptionKey(String aseDbEncryptionKey) {
    this.aseDbEncryptionKey = aseDbEncryptionKey;
  }


  public Snapshot mssqlInternalVersion(Integer mssqlInternalVersion) {
    this.mssqlInternalVersion = mssqlInternalVersion;
    return this;
  }

   /**
   * Internal version of the source database at the time the snapshot was taken.
   * @return mssqlInternalVersion
  **/
  @javax.annotation.Nullable
  public Integer getMssqlInternalVersion() {
    return mssqlInternalVersion;
  }

  public void setMssqlInternalVersion(Integer mssqlInternalVersion) {
    this.mssqlInternalVersion = mssqlInternalVersion;
  }


  public Snapshot mssqlBackupSetUuid(String mssqlBackupSetUuid) {
    this.mssqlBackupSetUuid = mssqlBackupSetUuid;
    return this;
  }

   /**
   * UUID of the source database backup that was restored for this snapshot.
   * @return mssqlBackupSetUuid
  **/
  @javax.annotation.Nullable
  public String getMssqlBackupSetUuid() {
    return mssqlBackupSetUuid;
  }

  public void setMssqlBackupSetUuid(String mssqlBackupSetUuid) {
    this.mssqlBackupSetUuid = mssqlBackupSetUuid;
  }


  public Snapshot mssqlBackupSoftwareType(MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType) {
    this.mssqlBackupSoftwareType = mssqlBackupSoftwareType;
    return this;
  }

   /**
   * Backup software used to restore the source database backup for this snapshot
   * @return mssqlBackupSoftwareType
  **/
  @javax.annotation.Nullable
  public MssqlBackupSoftwareTypeEnum getMssqlBackupSoftwareType() {
    return mssqlBackupSoftwareType;
  }

  public void setMssqlBackupSoftwareType(MssqlBackupSoftwareTypeEnum mssqlBackupSoftwareType) {
    this.mssqlBackupSoftwareType = mssqlBackupSoftwareType;
  }


  public Snapshot mssqlBackupLocationType(MssqlBackupLocationTypeEnum mssqlBackupLocationType) {
    this.mssqlBackupLocationType = mssqlBackupLocationType;
    return this;
  }

   /**
   * Backup software used to restore the source database backup for this snapshot
   * @return mssqlBackupLocationType
  **/
  @javax.annotation.Nullable
  public MssqlBackupLocationTypeEnum getMssqlBackupLocationType() {
    return mssqlBackupLocationType;
  }

  public void setMssqlBackupLocationType(MssqlBackupLocationTypeEnum mssqlBackupLocationType) {
    this.mssqlBackupLocationType = mssqlBackupLocationType;
  }


  public Snapshot mssqlEmptySnapshot(Boolean mssqlEmptySnapshot) {
    this.mssqlEmptySnapshot = mssqlEmptySnapshot;
    return this;
  }

   /**
   * True if the staging push dSource snapshot is empty.
   * @return mssqlEmptySnapshot
  **/
  @javax.annotation.Nullable
  public Boolean getMssqlEmptySnapshot() {
    return mssqlEmptySnapshot;
  }

  public void setMssqlEmptySnapshot(Boolean mssqlEmptySnapshot) {
    this.mssqlEmptySnapshot = mssqlEmptySnapshot;
  }


  public Snapshot oracleFromPhysicalStandbyVdb(Boolean oracleFromPhysicalStandbyVdb) {
    this.oracleFromPhysicalStandbyVdb = oracleFromPhysicalStandbyVdb;
    return this;
  }

   /**
   * True if this snapshot was taken of a standby database.
   * @return oracleFromPhysicalStandbyVdb
  **/
  @javax.annotation.Nullable
  public Boolean getOracleFromPhysicalStandbyVdb() {
    return oracleFromPhysicalStandbyVdb;
  }

  public void setOracleFromPhysicalStandbyVdb(Boolean oracleFromPhysicalStandbyVdb) {
    this.oracleFromPhysicalStandbyVdb = oracleFromPhysicalStandbyVdb;
  }


  public Snapshot oracleRedoLogSizeInBytes(Long oracleRedoLogSizeInBytes) {
    this.oracleRedoLogSizeInBytes = oracleRedoLogSizeInBytes;
    return this;
  }

   /**
   * Online redo log size in bytes when this snapshot was taken.
   * @return oracleRedoLogSizeInBytes
  **/
  @javax.annotation.Nullable
  public Long getOracleRedoLogSizeInBytes() {
    return oracleRedoLogSizeInBytes;
  }

  public void setOracleRedoLogSizeInBytes(Long oracleRedoLogSizeInBytes) {
    this.oracleRedoLogSizeInBytes = oracleRedoLogSizeInBytes;
  }


  public Snapshot tags(List<Tag> tags) {
    this.tags = tags;
    return this;
  }

  public Snapshot addTagsItem(Tag tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * Get tags
   * @return tags
  **/
  @javax.annotation.Nullable
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Snapshot snapshot = (Snapshot) o;
    return Objects.equals(this.id, snapshot.id) &&
        Objects.equals(this.engineId, snapshot.engineId) &&
        Objects.equals(this.namespace, snapshot.namespace) &&
        Objects.equals(this.name, snapshot.name) &&
        Objects.equals(this.namespaceId, snapshot.namespaceId) &&
        Objects.equals(this.namespaceName, snapshot.namespaceName) &&
        Objects.equals(this.isReplica, snapshot.isReplica) &&
        Objects.equals(this.consistency, snapshot.consistency) &&
        Objects.equals(this.missingNonLoggedData, snapshot.missingNonLoggedData) &&
        Objects.equals(this.datasetId, snapshot.datasetId) &&
        Objects.equals(this.creationTime, snapshot.creationTime) &&
        Objects.equals(this.startTimestamp, snapshot.startTimestamp) &&
        Objects.equals(this.startLocation, snapshot.startLocation) &&
        Objects.equals(this.timestamp, snapshot.timestamp) &&
        Objects.equals(this.location, snapshot.location) &&
        Objects.equals(this.retention, snapshot.retention) &&
        Objects.equals(this.expiration, snapshot.expiration) &&
        Objects.equals(this.retainForever, snapshot.retainForever) &&
        Objects.equals(this.effectiveExpiration, snapshot.effectiveExpiration) &&
        Objects.equals(this.effectiveRetainForever, snapshot.effectiveRetainForever) &&
        Objects.equals(this.timeflowId, snapshot.timeflowId) &&
        Objects.equals(this.timezone, snapshot.timezone) &&
        Objects.equals(this.version, snapshot.version) &&
        Objects.equals(this.temporary, snapshot.temporary) &&
        Objects.equals(this.appdataToolkit, snapshot.appdataToolkit) &&
        Objects.equals(this.appdataMetadata, snapshot.appdataMetadata) &&
        Objects.equals(this.aseDbEncryptionKey, snapshot.aseDbEncryptionKey) &&
        Objects.equals(this.mssqlInternalVersion, snapshot.mssqlInternalVersion) &&
        Objects.equals(this.mssqlBackupSetUuid, snapshot.mssqlBackupSetUuid) &&
        Objects.equals(this.mssqlBackupSoftwareType, snapshot.mssqlBackupSoftwareType) &&
        Objects.equals(this.mssqlBackupLocationType, snapshot.mssqlBackupLocationType) &&
        Objects.equals(this.mssqlEmptySnapshot, snapshot.mssqlEmptySnapshot) &&
        Objects.equals(this.oracleFromPhysicalStandbyVdb, snapshot.oracleFromPhysicalStandbyVdb) &&
        Objects.equals(this.oracleRedoLogSizeInBytes, snapshot.oracleRedoLogSizeInBytes) &&
        Objects.equals(this.tags, snapshot.tags);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, engineId, namespace, name, namespaceId, namespaceName, isReplica, consistency, missingNonLoggedData, datasetId, creationTime, startTimestamp, startLocation, timestamp, location, retention, expiration, retainForever, effectiveExpiration, effectiveRetainForever, timeflowId, timezone, version, temporary, appdataToolkit, appdataMetadata, aseDbEncryptionKey, mssqlInternalVersion, mssqlBackupSetUuid, mssqlBackupSoftwareType, mssqlBackupLocationType, mssqlEmptySnapshot, oracleFromPhysicalStandbyVdb, oracleRedoLogSizeInBytes, tags);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Snapshot {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    engineId: ").append(toIndentedString(engineId)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespaceId: ").append(toIndentedString(namespaceId)).append("\n");
    sb.append("    namespaceName: ").append(toIndentedString(namespaceName)).append("\n");
    sb.append("    isReplica: ").append(toIndentedString(isReplica)).append("\n");
    sb.append("    consistency: ").append(toIndentedString(consistency)).append("\n");
    sb.append("    missingNonLoggedData: ").append(toIndentedString(missingNonLoggedData)).append("\n");
    sb.append("    datasetId: ").append(toIndentedString(datasetId)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    startTimestamp: ").append(toIndentedString(startTimestamp)).append("\n");
    sb.append("    startLocation: ").append(toIndentedString(startLocation)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    retention: ").append(toIndentedString(retention)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    retainForever: ").append(toIndentedString(retainForever)).append("\n");
    sb.append("    effectiveExpiration: ").append(toIndentedString(effectiveExpiration)).append("\n");
    sb.append("    effectiveRetainForever: ").append(toIndentedString(effectiveRetainForever)).append("\n");
    sb.append("    timeflowId: ").append(toIndentedString(timeflowId)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    temporary: ").append(toIndentedString(temporary)).append("\n");
    sb.append("    appdataToolkit: ").append(toIndentedString(appdataToolkit)).append("\n");
    sb.append("    appdataMetadata: ").append(toIndentedString(appdataMetadata)).append("\n");
    sb.append("    aseDbEncryptionKey: ").append(toIndentedString(aseDbEncryptionKey)).append("\n");
    sb.append("    mssqlInternalVersion: ").append(toIndentedString(mssqlInternalVersion)).append("\n");
    sb.append("    mssqlBackupSetUuid: ").append(toIndentedString(mssqlBackupSetUuid)).append("\n");
    sb.append("    mssqlBackupSoftwareType: ").append(toIndentedString(mssqlBackupSoftwareType)).append("\n");
    sb.append("    mssqlBackupLocationType: ").append(toIndentedString(mssqlBackupLocationType)).append("\n");
    sb.append("    mssqlEmptySnapshot: ").append(toIndentedString(mssqlEmptySnapshot)).append("\n");
    sb.append("    oracleFromPhysicalStandbyVdb: ").append(toIndentedString(oracleFromPhysicalStandbyVdb)).append("\n");
    sb.append("    oracleRedoLogSizeInBytes: ").append(toIndentedString(oracleRedoLogSizeInBytes)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("engine_id");
    openapiFields.add("namespace");
    openapiFields.add("name");
    openapiFields.add("namespace_id");
    openapiFields.add("namespace_name");
    openapiFields.add("is_replica");
    openapiFields.add("consistency");
    openapiFields.add("missing_non_logged_data");
    openapiFields.add("dataset_id");
    openapiFields.add("creation_time");
    openapiFields.add("start_timestamp");
    openapiFields.add("start_location");
    openapiFields.add("timestamp");
    openapiFields.add("location");
    openapiFields.add("retention");
    openapiFields.add("expiration");
    openapiFields.add("retain_forever");
    openapiFields.add("effective_expiration");
    openapiFields.add("effective_retain_forever");
    openapiFields.add("timeflow_id");
    openapiFields.add("timezone");
    openapiFields.add("version");
    openapiFields.add("temporary");
    openapiFields.add("appdata_toolkit");
    openapiFields.add("appdata_metadata");
    openapiFields.add("ase_db_encryption_key");
    openapiFields.add("mssql_internal_version");
    openapiFields.add("mssql_backup_set_uuid");
    openapiFields.add("mssql_backup_software_type");
    openapiFields.add("mssql_backup_location_type");
    openapiFields.add("mssql_empty_snapshot");
    openapiFields.add("oracle_from_physical_standby_vdb");
    openapiFields.add("oracle_redo_log_size_in_bytes");
    openapiFields.add("tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Snapshot
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Snapshot.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Snapshot is not found in the empty JSON string", Snapshot.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Snapshot.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Snapshot` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("engine_id") != null && !jsonObj.get("engine_id").isJsonNull()) && !jsonObj.get("engine_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `engine_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("engine_id").toString()));
      }
      if ((jsonObj.get("namespace") != null && !jsonObj.get("namespace").isJsonNull()) && !jsonObj.get("namespace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespace").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("namespace_id") != null && !jsonObj.get("namespace_id").isJsonNull()) && !jsonObj.get("namespace_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespace_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespace_id").toString()));
      }
      if ((jsonObj.get("namespace_name") != null && !jsonObj.get("namespace_name").isJsonNull()) && !jsonObj.get("namespace_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespace_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespace_name").toString()));
      }
      if ((jsonObj.get("consistency") != null && !jsonObj.get("consistency").isJsonNull()) && !jsonObj.get("consistency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `consistency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("consistency").toString()));
      }
      // validate the optional field `consistency`
      if (jsonObj.get("consistency") != null && !jsonObj.get("consistency").isJsonNull()) {
        ConsistencyEnum.validateJsonElement(jsonObj.get("consistency"));
      }
      if ((jsonObj.get("dataset_id") != null && !jsonObj.get("dataset_id").isJsonNull()) && !jsonObj.get("dataset_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataset_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataset_id").toString()));
      }
      if ((jsonObj.get("start_location") != null && !jsonObj.get("start_location").isJsonNull()) && !jsonObj.get("start_location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `start_location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("start_location").toString()));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      if ((jsonObj.get("timeflow_id") != null && !jsonObj.get("timeflow_id").isJsonNull()) && !jsonObj.get("timeflow_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeflow_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeflow_id").toString()));
      }
      if ((jsonObj.get("timezone") != null && !jsonObj.get("timezone").isJsonNull()) && !jsonObj.get("timezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezone").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if ((jsonObj.get("appdata_toolkit") != null && !jsonObj.get("appdata_toolkit").isJsonNull()) && !jsonObj.get("appdata_toolkit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `appdata_toolkit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("appdata_toolkit").toString()));
      }
      if ((jsonObj.get("appdata_metadata") != null && !jsonObj.get("appdata_metadata").isJsonNull()) && !jsonObj.get("appdata_metadata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `appdata_metadata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("appdata_metadata").toString()));
      }
      if ((jsonObj.get("ase_db_encryption_key") != null && !jsonObj.get("ase_db_encryption_key").isJsonNull()) && !jsonObj.get("ase_db_encryption_key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ase_db_encryption_key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ase_db_encryption_key").toString()));
      }
      if ((jsonObj.get("mssql_backup_set_uuid") != null && !jsonObj.get("mssql_backup_set_uuid").isJsonNull()) && !jsonObj.get("mssql_backup_set_uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mssql_backup_set_uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mssql_backup_set_uuid").toString()));
      }
      if ((jsonObj.get("mssql_backup_software_type") != null && !jsonObj.get("mssql_backup_software_type").isJsonNull()) && !jsonObj.get("mssql_backup_software_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mssql_backup_software_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mssql_backup_software_type").toString()));
      }
      // validate the optional field `mssql_backup_software_type`
      if (jsonObj.get("mssql_backup_software_type") != null && !jsonObj.get("mssql_backup_software_type").isJsonNull()) {
        MssqlBackupSoftwareTypeEnum.validateJsonElement(jsonObj.get("mssql_backup_software_type"));
      }
      if ((jsonObj.get("mssql_backup_location_type") != null && !jsonObj.get("mssql_backup_location_type").isJsonNull()) && !jsonObj.get("mssql_backup_location_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mssql_backup_location_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mssql_backup_location_type").toString()));
      }
      // validate the optional field `mssql_backup_location_type`
      if (jsonObj.get("mssql_backup_location_type") != null && !jsonObj.get("mssql_backup_location_type").isJsonNull()) {
        MssqlBackupLocationTypeEnum.validateJsonElement(jsonObj.get("mssql_backup_location_type"));
      }
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull()) {
        JsonArray jsonArraytags = jsonObj.getAsJsonArray("tags");
        if (jsonArraytags != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tags").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
          }

          // validate the optional field `tags` (array)
          for (int i = 0; i < jsonArraytags.size(); i++) {
            Tag.validateJsonElement(jsonArraytags.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Snapshot.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Snapshot' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Snapshot> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Snapshot.class));

       return (TypeAdapter<T>) new TypeAdapter<Snapshot>() {
           @Override
           public void write(JsonWriter out, Snapshot value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Snapshot read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Snapshot given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Snapshot
  * @throws IOException if the JSON string is invalid with respect to Snapshot
  */
  public static Snapshot fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Snapshot.class);
  }

 /**
  * Convert an instance of Snapshot to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

