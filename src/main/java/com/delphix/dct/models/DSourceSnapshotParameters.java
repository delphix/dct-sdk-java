/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.3.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Parameters to snapshot a DSource.
 */
@ApiModel(description = "Parameters to snapshot a DSource.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-19T17:08:49.349376+05:30[Asia/Kolkata]")
public class DSourceSnapshotParameters {
  public static final String SERIALIZED_NAME_DROP_AND_RECREATE_DEVICES = "drop_and_recreate_devices";
  @SerializedName(SERIALIZED_NAME_DROP_AND_RECREATE_DEVICES)
  private Boolean dropAndRecreateDevices;

  /**
   * Determines how the Delphix Engine will take a backup: * &#x60;latest_backup&#x60; - Use the most recent backup. * &#x60;new_backup&#x60; - Delphix will take a new backup of your source database. * &#x60;specific_backup&#x60; - Use a specific backup. Using this option requires setting   &#x60;ase_backup_files&#x60; for ASE dSources or &#x60;mssql_backup_uuid&#x60; for MSSql dSources. Default is &#x60;new_backup&#x60;. (ASE, MSSql only) 
   */
  @JsonAdapter(SyncStrategyEnum.Adapter.class)
  public enum SyncStrategyEnum {
    LATEST_BACKUP("latest_backup"),
    
    NEW_BACKUP("new_backup"),
    
    SPECIFIC_BACKUP("specific_backup");

    private String value;

    SyncStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SyncStrategyEnum fromValue(String value) {
      for (SyncStrategyEnum b : SyncStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SyncStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SyncStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SyncStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SyncStrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_SYNC_STRATEGY = "sync_strategy";
  @SerializedName(SERIALIZED_NAME_SYNC_STRATEGY)
  private SyncStrategyEnum syncStrategy;

  public static final String SERIALIZED_NAME_ASE_BACKUP_FILES = "ase_backup_files";
  @SerializedName(SERIALIZED_NAME_ASE_BACKUP_FILES)
  private List<String> aseBackupFiles = null;

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_UUID = "mssql_backup_uuid";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_UUID)
  private String mssqlBackupUuid;

  public static final String SERIALIZED_NAME_COMPRESSION_ENABLED = "compression_enabled";
  @SerializedName(SERIALIZED_NAME_COMPRESSION_ENABLED)
  private Boolean compressionEnabled;

  /**
   * When using the &#x60;new_backup&#x60; sync_strategy for an MSSql Availability Group, determines the backup policy: * &#x60;primary&#x60; - Backups only go to the primary node. * &#x60;secondary_only&#x60; - Backups only go to secondary nodes. If secondary nodes are down, backups will fail. * &#x60;prefer_secondary&#x60; - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (MSSql only) 
   */
  @JsonAdapter(AvailabilityGroupBackupPolicyEnum.Adapter.class)
  public enum AvailabilityGroupBackupPolicyEnum {
    PRIMARY("primary"),
    
    SECONDARY_ONLY("secondary_only"),
    
    PREFER_SECONDARY("prefer_secondary");

    private String value;

    AvailabilityGroupBackupPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AvailabilityGroupBackupPolicyEnum fromValue(String value) {
      for (AvailabilityGroupBackupPolicyEnum b : AvailabilityGroupBackupPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AvailabilityGroupBackupPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AvailabilityGroupBackupPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AvailabilityGroupBackupPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AvailabilityGroupBackupPolicyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_AVAILABILITY_GROUP_BACKUP_POLICY = "availability_group_backup_policy";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_GROUP_BACKUP_POLICY)
  private AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy;

  public static final String SERIALIZED_NAME_DO_NOT_RESUME = "do_not_resume";
  @SerializedName(SERIALIZED_NAME_DO_NOT_RESUME)
  private Boolean doNotResume;

  public static final String SERIALIZED_NAME_DOUBLE_SYNC = "double_sync";
  @SerializedName(SERIALIZED_NAME_DOUBLE_SYNC)
  private Boolean doubleSync;

  public static final String SERIALIZED_NAME_FORCE_FULL_BACKUP = "force_full_backup";
  @SerializedName(SERIALIZED_NAME_FORCE_FULL_BACKUP)
  private Boolean forceFullBackup;

  public static final String SERIALIZED_NAME_SKIP_SPACE_CHECK = "skip_space_check";
  @SerializedName(SERIALIZED_NAME_SKIP_SPACE_CHECK)
  private Boolean skipSpaceCheck;

  public static final String SERIALIZED_NAME_FILES_FOR_PARTIAL_FULL_BACKUP = "files_for_partial_full_backup";
  @SerializedName(SERIALIZED_NAME_FILES_FOR_PARTIAL_FULL_BACKUP)
  private List<Long> filesForPartialFullBackup = null;


  public DSourceSnapshotParameters dropAndRecreateDevices(Boolean dropAndRecreateDevices) {
    
    this.dropAndRecreateDevices = dropAndRecreateDevices;
    return this;
  }

   /**
   * If this parameter is set to true, older devices will be dropped and new devices created instead of trying to remap the devices. This might increase the space utilization on Delphix Engine. (ASE only) 
   * @return dropAndRecreateDevices
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If this parameter is set to true, older devices will be dropped and new devices created instead of trying to remap the devices. This might increase the space utilization on Delphix Engine. (ASE only) ")

  public Boolean getDropAndRecreateDevices() {
    return dropAndRecreateDevices;
  }


  public void setDropAndRecreateDevices(Boolean dropAndRecreateDevices) {
    this.dropAndRecreateDevices = dropAndRecreateDevices;
  }


  public DSourceSnapshotParameters syncStrategy(SyncStrategyEnum syncStrategy) {
    
    this.syncStrategy = syncStrategy;
    return this;
  }

   /**
   * Determines how the Delphix Engine will take a backup: * &#x60;latest_backup&#x60; - Use the most recent backup. * &#x60;new_backup&#x60; - Delphix will take a new backup of your source database. * &#x60;specific_backup&#x60; - Use a specific backup. Using this option requires setting   &#x60;ase_backup_files&#x60; for ASE dSources or &#x60;mssql_backup_uuid&#x60; for MSSql dSources. Default is &#x60;new_backup&#x60;. (ASE, MSSql only) 
   * @return syncStrategy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines how the Delphix Engine will take a backup: * `latest_backup` - Use the most recent backup. * `new_backup` - Delphix will take a new backup of your source database. * `specific_backup` - Use a specific backup. Using this option requires setting   `ase_backup_files` for ASE dSources or `mssql_backup_uuid` for MSSql dSources. Default is `new_backup`. (ASE, MSSql only) ")

  public SyncStrategyEnum getSyncStrategy() {
    return syncStrategy;
  }


  public void setSyncStrategy(SyncStrategyEnum syncStrategy) {
    this.syncStrategy = syncStrategy;
  }


  public DSourceSnapshotParameters aseBackupFiles(List<String> aseBackupFiles) {
    
    this.aseBackupFiles = aseBackupFiles;
    return this;
  }

  public DSourceSnapshotParameters addAseBackupFilesItem(String aseBackupFilesItem) {
    if (this.aseBackupFiles == null) {
      this.aseBackupFiles = new ArrayList<String>();
    }
    this.aseBackupFiles.add(aseBackupFilesItem);
    return this;
  }

   /**
   * When using the &#x60;specific_backup&#x60; sync_strategy, determines the backup files. (ASE Only)
   * @return aseBackupFiles
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When using the `specific_backup` sync_strategy, determines the backup files. (ASE Only)")

  public List<String> getAseBackupFiles() {
    return aseBackupFiles;
  }


  public void setAseBackupFiles(List<String> aseBackupFiles) {
    this.aseBackupFiles = aseBackupFiles;
  }


  public DSourceSnapshotParameters mssqlBackupUuid(String mssqlBackupUuid) {
    
    this.mssqlBackupUuid = mssqlBackupUuid;
    return this;
  }

   /**
   * When using the &#x60;specific_backup&#x60; sync_strategy, determines the Backup Set UUID. (MSSql only)
   * @return mssqlBackupUuid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When using the `specific_backup` sync_strategy, determines the Backup Set UUID. (MSSql only)")

  public String getMssqlBackupUuid() {
    return mssqlBackupUuid;
  }


  public void setMssqlBackupUuid(String mssqlBackupUuid) {
    this.mssqlBackupUuid = mssqlBackupUuid;
  }


  public DSourceSnapshotParameters compressionEnabled(Boolean compressionEnabled) {
    
    this.compressionEnabled = compressionEnabled;
    return this;
  }

   /**
   * When using the &#x60;new_backup&#x60; sync_strategy, determines if compression must be enabled. Defaults to the configuration of the ingestion strategy configured on the Delphix Engine for this dSource. (MSSql only)
   * @return compressionEnabled
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When using the `new_backup` sync_strategy, determines if compression must be enabled. Defaults to the configuration of the ingestion strategy configured on the Delphix Engine for this dSource. (MSSql only)")

  public Boolean getCompressionEnabled() {
    return compressionEnabled;
  }


  public void setCompressionEnabled(Boolean compressionEnabled) {
    this.compressionEnabled = compressionEnabled;
  }


  public DSourceSnapshotParameters availabilityGroupBackupPolicy(AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy) {
    
    this.availabilityGroupBackupPolicy = availabilityGroupBackupPolicy;
    return this;
  }

   /**
   * When using the &#x60;new_backup&#x60; sync_strategy for an MSSql Availability Group, determines the backup policy: * &#x60;primary&#x60; - Backups only go to the primary node. * &#x60;secondary_only&#x60; - Backups only go to secondary nodes. If secondary nodes are down, backups will fail. * &#x60;prefer_secondary&#x60; - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (MSSql only) 
   * @return availabilityGroupBackupPolicy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "When using the `new_backup` sync_strategy for an MSSql Availability Group, determines the backup policy: * `primary` - Backups only go to the primary node. * `secondary_only` - Backups only go to secondary nodes. If secondary nodes are down, backups will fail. * `prefer_secondary` - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (MSSql only) ")

  public AvailabilityGroupBackupPolicyEnum getAvailabilityGroupBackupPolicy() {
    return availabilityGroupBackupPolicy;
  }


  public void setAvailabilityGroupBackupPolicy(AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy) {
    this.availabilityGroupBackupPolicy = availabilityGroupBackupPolicy;
  }


  public DSourceSnapshotParameters doNotResume(Boolean doNotResume) {
    
    this.doNotResume = doNotResume;
    return this;
  }

   /**
   * Indicates whether a fresh SnapSync must be started regardless if it was possible to resume the current SnapSync. If true, we will not resume but instead ignore previous progress and backup all datafiles even if already completed from previous failed SnapSync. This does not force a full backup, if an incremental was in progress this will start a new incremental snapshot. (Oracle only) 
   * @return doNotResume
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether a fresh SnapSync must be started regardless if it was possible to resume the current SnapSync. If true, we will not resume but instead ignore previous progress and backup all datafiles even if already completed from previous failed SnapSync. This does not force a full backup, if an incremental was in progress this will start a new incremental snapshot. (Oracle only) ")

  public Boolean getDoNotResume() {
    return doNotResume;
  }


  public void setDoNotResume(Boolean doNotResume) {
    this.doNotResume = doNotResume;
  }


  public DSourceSnapshotParameters doubleSync(Boolean doubleSync) {
    
    this.doubleSync = doubleSync;
    return this;
  }

   /**
   * Indicates whether two SnapSyncs should be performed in immediate succession to reduce the number of logs required to provision the snapshot. This may significantly reduce the time necessary to provision from a snapshot. (Oracle only). 
   * @return doubleSync
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates whether two SnapSyncs should be performed in immediate succession to reduce the number of logs required to provision the snapshot. This may significantly reduce the time necessary to provision from a snapshot. (Oracle only). ")

  public Boolean getDoubleSync() {
    return doubleSync;
  }


  public void setDoubleSync(Boolean doubleSync) {
    this.doubleSync = doubleSync;
  }


  public DSourceSnapshotParameters forceFullBackup(Boolean forceFullBackup) {
    
    this.forceFullBackup = forceFullBackup;
    return this;
  }

   /**
   * Whether or not to take another full backup of the source database. (Oracle only)
   * @return forceFullBackup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Whether or not to take another full backup of the source database. (Oracle only)")

  public Boolean getForceFullBackup() {
    return forceFullBackup;
  }


  public void setForceFullBackup(Boolean forceFullBackup) {
    this.forceFullBackup = forceFullBackup;
  }


  public DSourceSnapshotParameters skipSpaceCheck(Boolean skipSpaceCheck) {
    
    this.skipSpaceCheck = skipSpaceCheck;
    return this;
  }

   /**
   * Skip check that tests if there is enough space available to store the database in the Delphix Engine. The Delphix Engine estimates how much space a database will occupy after compression and prevents SnapSync if insufficient space is available. This safeguard can be overridden using this option. This may be useful when linking highly compressible databases. (Oracle only) 
   * @return skipSpaceCheck
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Skip check that tests if there is enough space available to store the database in the Delphix Engine. The Delphix Engine estimates how much space a database will occupy after compression and prevents SnapSync if insufficient space is available. This safeguard can be overridden using this option. This may be useful when linking highly compressible databases. (Oracle only) ")

  public Boolean getSkipSpaceCheck() {
    return skipSpaceCheck;
  }


  public void setSkipSpaceCheck(Boolean skipSpaceCheck) {
    this.skipSpaceCheck = skipSpaceCheck;
  }


  public DSourceSnapshotParameters filesForPartialFullBackup(List<Long> filesForPartialFullBackup) {
    
    this.filesForPartialFullBackup = filesForPartialFullBackup;
    return this;
  }

  public DSourceSnapshotParameters addFilesForPartialFullBackupItem(Long filesForPartialFullBackupItem) {
    if (this.filesForPartialFullBackup == null) {
      this.filesForPartialFullBackup = new ArrayList<Long>();
    }
    this.filesForPartialFullBackup.add(filesForPartialFullBackupItem);
    return this;
  }

   /**
   * List of datafiles to take a full backup of. This would be useful in situations where certain datafiles could not be backed up during previous SnapSync due to corruption or because they went offline. (Oracle only) 
   * @return filesForPartialFullBackup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "List of datafiles to take a full backup of. This would be useful in situations where certain datafiles could not be backed up during previous SnapSync due to corruption or because they went offline. (Oracle only) ")

  public List<Long> getFilesForPartialFullBackup() {
    return filesForPartialFullBackup;
  }


  public void setFilesForPartialFullBackup(List<Long> filesForPartialFullBackup) {
    this.filesForPartialFullBackup = filesForPartialFullBackup;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DSourceSnapshotParameters dsourceSnapshotParameters = (DSourceSnapshotParameters) o;
    return Objects.equals(this.dropAndRecreateDevices, dsourceSnapshotParameters.dropAndRecreateDevices) &&
        Objects.equals(this.syncStrategy, dsourceSnapshotParameters.syncStrategy) &&
        Objects.equals(this.aseBackupFiles, dsourceSnapshotParameters.aseBackupFiles) &&
        Objects.equals(this.mssqlBackupUuid, dsourceSnapshotParameters.mssqlBackupUuid) &&
        Objects.equals(this.compressionEnabled, dsourceSnapshotParameters.compressionEnabled) &&
        Objects.equals(this.availabilityGroupBackupPolicy, dsourceSnapshotParameters.availabilityGroupBackupPolicy) &&
        Objects.equals(this.doNotResume, dsourceSnapshotParameters.doNotResume) &&
        Objects.equals(this.doubleSync, dsourceSnapshotParameters.doubleSync) &&
        Objects.equals(this.forceFullBackup, dsourceSnapshotParameters.forceFullBackup) &&
        Objects.equals(this.skipSpaceCheck, dsourceSnapshotParameters.skipSpaceCheck) &&
        Objects.equals(this.filesForPartialFullBackup, dsourceSnapshotParameters.filesForPartialFullBackup);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dropAndRecreateDevices, syncStrategy, aseBackupFiles, mssqlBackupUuid, compressionEnabled, availabilityGroupBackupPolicy, doNotResume, doubleSync, forceFullBackup, skipSpaceCheck, filesForPartialFullBackup);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DSourceSnapshotParameters {\n");
    sb.append("    dropAndRecreateDevices: ").append(toIndentedString(dropAndRecreateDevices)).append("\n");
    sb.append("    syncStrategy: ").append(toIndentedString(syncStrategy)).append("\n");
    sb.append("    aseBackupFiles: ").append(toIndentedString(aseBackupFiles)).append("\n");
    sb.append("    mssqlBackupUuid: ").append(toIndentedString(mssqlBackupUuid)).append("\n");
    sb.append("    compressionEnabled: ").append(toIndentedString(compressionEnabled)).append("\n");
    sb.append("    availabilityGroupBackupPolicy: ").append(toIndentedString(availabilityGroupBackupPolicy)).append("\n");
    sb.append("    doNotResume: ").append(toIndentedString(doNotResume)).append("\n");
    sb.append("    doubleSync: ").append(toIndentedString(doubleSync)).append("\n");
    sb.append("    forceFullBackup: ").append(toIndentedString(forceFullBackup)).append("\n");
    sb.append("    skipSpaceCheck: ").append(toIndentedString(skipSpaceCheck)).append("\n");
    sb.append("    filesForPartialFullBackup: ").append(toIndentedString(filesForPartialFullBackup)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

