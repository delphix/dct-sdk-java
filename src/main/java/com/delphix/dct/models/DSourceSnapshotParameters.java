/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.10.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.delphix.dct.JSON;

/**
 * Parameters to snapshot a DSource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-04T14:49:34.152994+05:30[Asia/Kolkata]", comments = "Generator version: 7.4.0")
public class DSourceSnapshotParameters {
  public static final String SERIALIZED_NAME_DROP_AND_RECREATE_DEVICES = "drop_and_recreate_devices";
  @SerializedName(SERIALIZED_NAME_DROP_AND_RECREATE_DEVICES)
  private Boolean dropAndRecreateDevices;

  /**
   * Determines how the Delphix Engine will take a backup: * &#x60;latest_backup&#x60; - Use the most recent backup. * &#x60;new_backup&#x60; - Delphix will take a new backup of your source database. * &#x60;specific_backup&#x60; - Use a specific backup. Using this option requires setting   &#x60;ase_backup_files&#x60; for ASE dSources or &#x60;mssql_backup_uuid&#x60; for MSSql dSources. Default is &#x60;new_backup&#x60;. (ASE, MSSql only) 
   */
  @JsonAdapter(SyncStrategyEnum.Adapter.class)
  public enum SyncStrategyEnum {
    LATEST_BACKUP("latest_backup"),
    
    NEW_BACKUP("new_backup"),
    
    SPECIFIC_BACKUP("specific_backup");

    private String value;

    SyncStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SyncStrategyEnum fromValue(String value) {
      for (SyncStrategyEnum b : SyncStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SyncStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SyncStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SyncStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SyncStrategyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SyncStrategyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SYNC_STRATEGY = "sync_strategy";
  @SerializedName(SERIALIZED_NAME_SYNC_STRATEGY)
  private SyncStrategyEnum syncStrategy;

  public static final String SERIALIZED_NAME_ASE_BACKUP_FILES = "ase_backup_files";
  @SerializedName(SERIALIZED_NAME_ASE_BACKUP_FILES)
  private List<String> aseBackupFiles;

  public static final String SERIALIZED_NAME_MSSQL_BACKUP_UUID = "mssql_backup_uuid";
  @SerializedName(SERIALIZED_NAME_MSSQL_BACKUP_UUID)
  private String mssqlBackupUuid;

  public static final String SERIALIZED_NAME_COMPRESSION_ENABLED = "compression_enabled";
  @SerializedName(SERIALIZED_NAME_COMPRESSION_ENABLED)
  private Boolean compressionEnabled;

  /**
   * When using the &#x60;new_backup&#x60; sync_strategy for an MSSql Availability Group, determines the backup policy: * &#x60;primary&#x60; - Backups only go to the primary node. * &#x60;secondary_only&#x60; - Backups only go to secondary nodes. If secondary nodes are down, backups will fail. * &#x60;prefer_secondary&#x60; - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (MSSql only) 
   */
  @JsonAdapter(AvailabilityGroupBackupPolicyEnum.Adapter.class)
  public enum AvailabilityGroupBackupPolicyEnum {
    PRIMARY("primary"),
    
    SECONDARY_ONLY("secondary_only"),
    
    PREFER_SECONDARY("prefer_secondary");

    private String value;

    AvailabilityGroupBackupPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AvailabilityGroupBackupPolicyEnum fromValue(String value) {
      for (AvailabilityGroupBackupPolicyEnum b : AvailabilityGroupBackupPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AvailabilityGroupBackupPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AvailabilityGroupBackupPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AvailabilityGroupBackupPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AvailabilityGroupBackupPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AvailabilityGroupBackupPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AVAILABILITY_GROUP_BACKUP_POLICY = "availability_group_backup_policy";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_GROUP_BACKUP_POLICY)
  private AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy;

  public static final String SERIALIZED_NAME_DO_NOT_RESUME = "do_not_resume";
  @SerializedName(SERIALIZED_NAME_DO_NOT_RESUME)
  private Boolean doNotResume;

  public static final String SERIALIZED_NAME_DOUBLE_SYNC = "double_sync";
  @SerializedName(SERIALIZED_NAME_DOUBLE_SYNC)
  private Boolean doubleSync;

  public static final String SERIALIZED_NAME_FORCE_FULL_BACKUP = "force_full_backup";
  @SerializedName(SERIALIZED_NAME_FORCE_FULL_BACKUP)
  private Boolean forceFullBackup;

  public static final String SERIALIZED_NAME_SKIP_SPACE_CHECK = "skip_space_check";
  @SerializedName(SERIALIZED_NAME_SKIP_SPACE_CHECK)
  private Boolean skipSpaceCheck;

  public static final String SERIALIZED_NAME_FILES_FOR_PARTIAL_FULL_BACKUP = "files_for_partial_full_backup";
  @SerializedName(SERIALIZED_NAME_FILES_FOR_PARTIAL_FULL_BACKUP)
  private List<Long> filesForPartialFullBackup;

  public static final String SERIALIZED_NAME_APPDATA_PARAMETERS = "appdata_parameters";
  @SerializedName(SERIALIZED_NAME_APPDATA_PARAMETERS)
  private Map<String, Object> appdataParameters;

  public DSourceSnapshotParameters() {
  }

  public DSourceSnapshotParameters dropAndRecreateDevices(Boolean dropAndRecreateDevices) {
    this.dropAndRecreateDevices = dropAndRecreateDevices;
    return this;
  }

   /**
   * If this parameter is set to true, older devices will be dropped and new devices created instead of trying to remap the devices. This might increase the space utilization on Delphix Engine. (ASE only) 
   * @return dropAndRecreateDevices
  **/
  @javax.annotation.Nullable
  public Boolean getDropAndRecreateDevices() {
    return dropAndRecreateDevices;
  }

  public void setDropAndRecreateDevices(Boolean dropAndRecreateDevices) {
    this.dropAndRecreateDevices = dropAndRecreateDevices;
  }


  public DSourceSnapshotParameters syncStrategy(SyncStrategyEnum syncStrategy) {
    this.syncStrategy = syncStrategy;
    return this;
  }

   /**
   * Determines how the Delphix Engine will take a backup: * &#x60;latest_backup&#x60; - Use the most recent backup. * &#x60;new_backup&#x60; - Delphix will take a new backup of your source database. * &#x60;specific_backup&#x60; - Use a specific backup. Using this option requires setting   &#x60;ase_backup_files&#x60; for ASE dSources or &#x60;mssql_backup_uuid&#x60; for MSSql dSources. Default is &#x60;new_backup&#x60;. (ASE, MSSql only) 
   * @return syncStrategy
  **/
  @javax.annotation.Nullable
  public SyncStrategyEnum getSyncStrategy() {
    return syncStrategy;
  }

  public void setSyncStrategy(SyncStrategyEnum syncStrategy) {
    this.syncStrategy = syncStrategy;
  }


  public DSourceSnapshotParameters aseBackupFiles(List<String> aseBackupFiles) {
    this.aseBackupFiles = aseBackupFiles;
    return this;
  }

  public DSourceSnapshotParameters addAseBackupFilesItem(String aseBackupFilesItem) {
    if (this.aseBackupFiles == null) {
      this.aseBackupFiles = new ArrayList<>();
    }
    this.aseBackupFiles.add(aseBackupFilesItem);
    return this;
  }

   /**
   * When using the &#x60;specific_backup&#x60; sync_strategy, determines the backup files. (ASE Only)
   * @return aseBackupFiles
  **/
  @javax.annotation.Nullable
  public List<String> getAseBackupFiles() {
    return aseBackupFiles;
  }

  public void setAseBackupFiles(List<String> aseBackupFiles) {
    this.aseBackupFiles = aseBackupFiles;
  }


  public DSourceSnapshotParameters mssqlBackupUuid(String mssqlBackupUuid) {
    this.mssqlBackupUuid = mssqlBackupUuid;
    return this;
  }

   /**
   * When using the &#x60;specific_backup&#x60; sync_strategy, determines the Backup Set UUID. (MSSql only)
   * @return mssqlBackupUuid
  **/
  @javax.annotation.Nullable
  public String getMssqlBackupUuid() {
    return mssqlBackupUuid;
  }

  public void setMssqlBackupUuid(String mssqlBackupUuid) {
    this.mssqlBackupUuid = mssqlBackupUuid;
  }


  public DSourceSnapshotParameters compressionEnabled(Boolean compressionEnabled) {
    this.compressionEnabled = compressionEnabled;
    return this;
  }

   /**
   * When using the &#x60;new_backup&#x60; sync_strategy, determines if compression must be enabled. Defaults to the configuration of the ingestion strategy configured on the Delphix Engine for this dSource. (MSSql only)
   * @return compressionEnabled
  **/
  @javax.annotation.Nullable
  public Boolean getCompressionEnabled() {
    return compressionEnabled;
  }

  public void setCompressionEnabled(Boolean compressionEnabled) {
    this.compressionEnabled = compressionEnabled;
  }


  public DSourceSnapshotParameters availabilityGroupBackupPolicy(AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy) {
    this.availabilityGroupBackupPolicy = availabilityGroupBackupPolicy;
    return this;
  }

   /**
   * When using the &#x60;new_backup&#x60; sync_strategy for an MSSql Availability Group, determines the backup policy: * &#x60;primary&#x60; - Backups only go to the primary node. * &#x60;secondary_only&#x60; - Backups only go to secondary nodes. If secondary nodes are down, backups will fail. * &#x60;prefer_secondary&#x60; - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (MSSql only) 
   * @return availabilityGroupBackupPolicy
  **/
  @javax.annotation.Nullable
  public AvailabilityGroupBackupPolicyEnum getAvailabilityGroupBackupPolicy() {
    return availabilityGroupBackupPolicy;
  }

  public void setAvailabilityGroupBackupPolicy(AvailabilityGroupBackupPolicyEnum availabilityGroupBackupPolicy) {
    this.availabilityGroupBackupPolicy = availabilityGroupBackupPolicy;
  }


  public DSourceSnapshotParameters doNotResume(Boolean doNotResume) {
    this.doNotResume = doNotResume;
    return this;
  }

   /**
   * Indicates whether a fresh SnapSync must be started regardless if it was possible to resume the current SnapSync. If true, we will not resume but instead ignore previous progress and backup all datafiles even if already completed from previous failed SnapSync. This does not force a full backup, if an incremental was in progress this will start a new incremental snapshot. (Oracle only) 
   * @return doNotResume
  **/
  @javax.annotation.Nullable
  public Boolean getDoNotResume() {
    return doNotResume;
  }

  public void setDoNotResume(Boolean doNotResume) {
    this.doNotResume = doNotResume;
  }


  public DSourceSnapshotParameters doubleSync(Boolean doubleSync) {
    this.doubleSync = doubleSync;
    return this;
  }

   /**
   * Indicates whether two SnapSyncs should be performed in immediate succession to reduce the number of logs required to provision the snapshot. This may significantly reduce the time necessary to provision from a snapshot. (Oracle only). 
   * @return doubleSync
  **/
  @javax.annotation.Nullable
  public Boolean getDoubleSync() {
    return doubleSync;
  }

  public void setDoubleSync(Boolean doubleSync) {
    this.doubleSync = doubleSync;
  }


  public DSourceSnapshotParameters forceFullBackup(Boolean forceFullBackup) {
    this.forceFullBackup = forceFullBackup;
    return this;
  }

   /**
   * Whether or not to take another full backup of the source database. (Oracle only)
   * @return forceFullBackup
  **/
  @javax.annotation.Nullable
  public Boolean getForceFullBackup() {
    return forceFullBackup;
  }

  public void setForceFullBackup(Boolean forceFullBackup) {
    this.forceFullBackup = forceFullBackup;
  }


  public DSourceSnapshotParameters skipSpaceCheck(Boolean skipSpaceCheck) {
    this.skipSpaceCheck = skipSpaceCheck;
    return this;
  }

   /**
   * Skip check that tests if there is enough space available to store the database in the Delphix Engine. The Delphix Engine estimates how much space a database will occupy after compression and prevents SnapSync if insufficient space is available. This safeguard can be overridden using this option. This may be useful when linking highly compressible databases. (Oracle only) 
   * @return skipSpaceCheck
  **/
  @javax.annotation.Nullable
  public Boolean getSkipSpaceCheck() {
    return skipSpaceCheck;
  }

  public void setSkipSpaceCheck(Boolean skipSpaceCheck) {
    this.skipSpaceCheck = skipSpaceCheck;
  }


  public DSourceSnapshotParameters filesForPartialFullBackup(List<Long> filesForPartialFullBackup) {
    this.filesForPartialFullBackup = filesForPartialFullBackup;
    return this;
  }

  public DSourceSnapshotParameters addFilesForPartialFullBackupItem(Long filesForPartialFullBackupItem) {
    if (this.filesForPartialFullBackup == null) {
      this.filesForPartialFullBackup = new ArrayList<>();
    }
    this.filesForPartialFullBackup.add(filesForPartialFullBackupItem);
    return this;
  }

   /**
   * List of datafiles to take a full backup of. This would be useful in situations where certain datafiles could not be backed up during previous SnapSync due to corruption or because they went offline. (Oracle only) 
   * @return filesForPartialFullBackup
  **/
  @javax.annotation.Nullable
  public List<Long> getFilesForPartialFullBackup() {
    return filesForPartialFullBackup;
  }

  public void setFilesForPartialFullBackup(List<Long> filesForPartialFullBackup) {
    this.filesForPartialFullBackup = filesForPartialFullBackup;
  }


  public DSourceSnapshotParameters appdataParameters(Map<String, Object> appdataParameters) {
    this.appdataParameters = appdataParameters;
    return this;
  }

  public DSourceSnapshotParameters putAppdataParametersItem(String key, Object appdataParametersItem) {
    if (this.appdataParameters == null) {
      this.appdataParameters = new HashMap<>();
    }
    this.appdataParameters.put(key, appdataParametersItem);
    return this;
  }

   /**
   * The list of parameters specified by the snapshotParametersDefinition schema in the toolkit (AppData only).
   * @return appdataParameters
  **/
  @javax.annotation.Nullable
  public Map<String, Object> getAppdataParameters() {
    return appdataParameters;
  }

  public void setAppdataParameters(Map<String, Object> appdataParameters) {
    this.appdataParameters = appdataParameters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DSourceSnapshotParameters dsourceSnapshotParameters = (DSourceSnapshotParameters) o;
    return Objects.equals(this.dropAndRecreateDevices, dsourceSnapshotParameters.dropAndRecreateDevices) &&
        Objects.equals(this.syncStrategy, dsourceSnapshotParameters.syncStrategy) &&
        Objects.equals(this.aseBackupFiles, dsourceSnapshotParameters.aseBackupFiles) &&
        Objects.equals(this.mssqlBackupUuid, dsourceSnapshotParameters.mssqlBackupUuid) &&
        Objects.equals(this.compressionEnabled, dsourceSnapshotParameters.compressionEnabled) &&
        Objects.equals(this.availabilityGroupBackupPolicy, dsourceSnapshotParameters.availabilityGroupBackupPolicy) &&
        Objects.equals(this.doNotResume, dsourceSnapshotParameters.doNotResume) &&
        Objects.equals(this.doubleSync, dsourceSnapshotParameters.doubleSync) &&
        Objects.equals(this.forceFullBackup, dsourceSnapshotParameters.forceFullBackup) &&
        Objects.equals(this.skipSpaceCheck, dsourceSnapshotParameters.skipSpaceCheck) &&
        Objects.equals(this.filesForPartialFullBackup, dsourceSnapshotParameters.filesForPartialFullBackup) &&
        Objects.equals(this.appdataParameters, dsourceSnapshotParameters.appdataParameters);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(dropAndRecreateDevices, syncStrategy, aseBackupFiles, mssqlBackupUuid, compressionEnabled, availabilityGroupBackupPolicy, doNotResume, doubleSync, forceFullBackup, skipSpaceCheck, filesForPartialFullBackup, appdataParameters);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DSourceSnapshotParameters {\n");
    sb.append("    dropAndRecreateDevices: ").append(toIndentedString(dropAndRecreateDevices)).append("\n");
    sb.append("    syncStrategy: ").append(toIndentedString(syncStrategy)).append("\n");
    sb.append("    aseBackupFiles: ").append(toIndentedString(aseBackupFiles)).append("\n");
    sb.append("    mssqlBackupUuid: ").append(toIndentedString(mssqlBackupUuid)).append("\n");
    sb.append("    compressionEnabled: ").append(toIndentedString(compressionEnabled)).append("\n");
    sb.append("    availabilityGroupBackupPolicy: ").append(toIndentedString(availabilityGroupBackupPolicy)).append("\n");
    sb.append("    doNotResume: ").append(toIndentedString(doNotResume)).append("\n");
    sb.append("    doubleSync: ").append(toIndentedString(doubleSync)).append("\n");
    sb.append("    forceFullBackup: ").append(toIndentedString(forceFullBackup)).append("\n");
    sb.append("    skipSpaceCheck: ").append(toIndentedString(skipSpaceCheck)).append("\n");
    sb.append("    filesForPartialFullBackup: ").append(toIndentedString(filesForPartialFullBackup)).append("\n");
    sb.append("    appdataParameters: ").append(toIndentedString(appdataParameters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("drop_and_recreate_devices");
    openapiFields.add("sync_strategy");
    openapiFields.add("ase_backup_files");
    openapiFields.add("mssql_backup_uuid");
    openapiFields.add("compression_enabled");
    openapiFields.add("availability_group_backup_policy");
    openapiFields.add("do_not_resume");
    openapiFields.add("double_sync");
    openapiFields.add("force_full_backup");
    openapiFields.add("skip_space_check");
    openapiFields.add("files_for_partial_full_backup");
    openapiFields.add("appdata_parameters");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to DSourceSnapshotParameters
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DSourceSnapshotParameters.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DSourceSnapshotParameters is not found in the empty JSON string", DSourceSnapshotParameters.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DSourceSnapshotParameters.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DSourceSnapshotParameters` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("sync_strategy") != null && !jsonObj.get("sync_strategy").isJsonNull()) && !jsonObj.get("sync_strategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sync_strategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sync_strategy").toString()));
      }
      // validate the optional field `sync_strategy`
      if (jsonObj.get("sync_strategy") != null && !jsonObj.get("sync_strategy").isJsonNull()) {
        SyncStrategyEnum.validateJsonElement(jsonObj.get("sync_strategy"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ase_backup_files") != null && !jsonObj.get("ase_backup_files").isJsonNull() && !jsonObj.get("ase_backup_files").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ase_backup_files` to be an array in the JSON string but got `%s`", jsonObj.get("ase_backup_files").toString()));
      }
      if ((jsonObj.get("mssql_backup_uuid") != null && !jsonObj.get("mssql_backup_uuid").isJsonNull()) && !jsonObj.get("mssql_backup_uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mssql_backup_uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mssql_backup_uuid").toString()));
      }
      if ((jsonObj.get("availability_group_backup_policy") != null && !jsonObj.get("availability_group_backup_policy").isJsonNull()) && !jsonObj.get("availability_group_backup_policy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availability_group_backup_policy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availability_group_backup_policy").toString()));
      }
      // validate the optional field `availability_group_backup_policy`
      if (jsonObj.get("availability_group_backup_policy") != null && !jsonObj.get("availability_group_backup_policy").isJsonNull()) {
        AvailabilityGroupBackupPolicyEnum.validateJsonElement(jsonObj.get("availability_group_backup_policy"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("files_for_partial_full_backup") != null && !jsonObj.get("files_for_partial_full_backup").isJsonNull() && !jsonObj.get("files_for_partial_full_backup").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `files_for_partial_full_backup` to be an array in the JSON string but got `%s`", jsonObj.get("files_for_partial_full_backup").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DSourceSnapshotParameters.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DSourceSnapshotParameters' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DSourceSnapshotParameters> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DSourceSnapshotParameters.class));

       return (TypeAdapter<T>) new TypeAdapter<DSourceSnapshotParameters>() {
           @Override
           public void write(JsonWriter out, DSourceSnapshotParameters value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DSourceSnapshotParameters read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DSourceSnapshotParameters given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DSourceSnapshotParameters
  * @throws IOException if the JSON string is invalid with respect to DSourceSnapshotParameters
  */
  public static DSourceSnapshotParameters fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DSourceSnapshotParameters.class);
  }

 /**
  * Convert an instance of DSourceSnapshotParameters to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

