/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.3.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.api;

import com.delphix.dct.ApiCallback;
import com.delphix.dct.ApiClient;
import com.delphix.dct.ApiException;
import com.delphix.dct.ApiResponse;
import com.delphix.dct.Configuration;
import com.delphix.dct.Pair;
import com.delphix.dct.ProgressRequestBody;
import com.delphix.dct.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.delphix.dct.models.CopyMaskingJobParameters;
import com.delphix.dct.models.CopyMaskingJobResponse;
import com.delphix.dct.models.DeleteMaskingJobResponse;
import com.delphix.dct.models.DeleteTag;
import com.delphix.dct.models.ExecuteMaskingJobParameters;
import com.delphix.dct.models.ExecuteMaskingJobResponse;
import com.delphix.dct.models.ListMaskingJobSourceEnginesResponse;
import com.delphix.dct.models.ListMaskingJobsResponse;
import com.delphix.dct.models.MaskingJob;
import com.delphix.dct.models.MaskingJobConnectorsResponse;
import com.delphix.dct.models.MigrateMaskingJobParameters;
import com.delphix.dct.models.MigrateMaskingJobResponse;
import com.delphix.dct.models.SearchBody;
import com.delphix.dct.models.SearchMaskingJobSourceEnginesResponse;
import com.delphix.dct.models.SearchMaskingJobsResponse;
import com.delphix.dct.models.TagsRequest;
import com.delphix.dct.models.TagsResponse;
import com.delphix.dct.models.UpdateMaskingJobParameters;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MaskingJobsApi {
    private ApiClient localVarApiClient;

    public MaskingJobsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MaskingJobsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for copyMaskingJob
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param copyMaskingJobParameters  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Copy masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call copyMaskingJobCall(String maskingJobId, CopyMaskingJobParameters copyMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = copyMaskingJobParameters;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/copy"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call copyMaskingJobValidateBeforeCall(String maskingJobId, CopyMaskingJobParameters copyMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling copyMaskingJob(Async)");
        }
        

        okhttp3.Call localVarCall = copyMaskingJobCall(maskingJobId, copyMaskingJobParameters, _callback);
        return localVarCall;

    }

    /**
     * Copies the masking job to another engine.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param copyMaskingJobParameters  (optional)
     * @return CopyMaskingJobResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Copy masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public CopyMaskingJobResponse copyMaskingJob(String maskingJobId, CopyMaskingJobParameters copyMaskingJobParameters) throws ApiException {
        ApiResponse<CopyMaskingJobResponse> localVarResp = copyMaskingJobWithHttpInfo(maskingJobId, copyMaskingJobParameters);
        return localVarResp.getData();
    }

    /**
     * Copies the masking job to another engine.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param copyMaskingJobParameters  (optional)
     * @return ApiResponse&lt;CopyMaskingJobResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Copy masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CopyMaskingJobResponse> copyMaskingJobWithHttpInfo(String maskingJobId, CopyMaskingJobParameters copyMaskingJobParameters) throws ApiException {
        okhttp3.Call localVarCall = copyMaskingJobValidateBeforeCall(maskingJobId, copyMaskingJobParameters, null);
        Type localVarReturnType = new TypeToken<CopyMaskingJobResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Copies the masking job to another engine. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param copyMaskingJobParameters  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Copy masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call copyMaskingJobAsync(String maskingJobId, CopyMaskingJobParameters copyMaskingJobParameters, final ApiCallback<CopyMaskingJobResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = copyMaskingJobValidateBeforeCall(maskingJobId, copyMaskingJobParameters, _callback);
        Type localVarReturnType = new TypeToken<CopyMaskingJobResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createMaskingJobTag
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param tagsRequest Tags information for Masking Job. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMaskingJobTagCall(String maskingJobId, TagsRequest tagsRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = tagsRequest;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/tags"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createMaskingJobTagValidateBeforeCall(String maskingJobId, TagsRequest tagsRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling createMaskingJobTag(Async)");
        }
        
        // verify the required parameter 'tagsRequest' is set
        if (tagsRequest == null) {
            throw new ApiException("Missing the required parameter 'tagsRequest' when calling createMaskingJobTag(Async)");
        }
        

        okhttp3.Call localVarCall = createMaskingJobTagCall(maskingJobId, tagsRequest, _callback);
        return localVarCall;

    }

    /**
     * Create tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param tagsRequest Tags information for Masking Job. (required)
     * @return TagsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public TagsResponse createMaskingJobTag(String maskingJobId, TagsRequest tagsRequest) throws ApiException {
        ApiResponse<TagsResponse> localVarResp = createMaskingJobTagWithHttpInfo(maskingJobId, tagsRequest);
        return localVarResp.getData();
    }

    /**
     * Create tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param tagsRequest Tags information for Masking Job. (required)
     * @return ApiResponse&lt;TagsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TagsResponse> createMaskingJobTagWithHttpInfo(String maskingJobId, TagsRequest tagsRequest) throws ApiException {
        okhttp3.Call localVarCall = createMaskingJobTagValidateBeforeCall(maskingJobId, tagsRequest, null);
        Type localVarReturnType = new TypeToken<TagsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create tags for a Masking Job. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param tagsRequest Tags information for Masking Job. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMaskingJobTagAsync(String maskingJobId, TagsRequest tagsRequest, final ApiCallback<TagsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createMaskingJobTagValidateBeforeCall(maskingJobId, tagsRequest, _callback);
        Type localVarReturnType = new TypeToken<TagsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteMaskingJob
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param force If true, ignores any failures to remove a masking job on an engine. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job delete initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMaskingJobCall(String maskingJobId, Boolean force, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("force", force));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMaskingJobValidateBeforeCall(String maskingJobId, Boolean force, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling deleteMaskingJob(Async)");
        }
        

        okhttp3.Call localVarCall = deleteMaskingJobCall(maskingJobId, force, _callback);
        return localVarCall;

    }

    /**
     * Delete a masking job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param force If true, ignores any failures to remove a masking job on an engine. (optional, default to false)
     * @return DeleteMaskingJobResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job delete initiated. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteMaskingJobResponse deleteMaskingJob(String maskingJobId, Boolean force) throws ApiException {
        ApiResponse<DeleteMaskingJobResponse> localVarResp = deleteMaskingJobWithHttpInfo(maskingJobId, force);
        return localVarResp.getData();
    }

    /**
     * Delete a masking job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param force If true, ignores any failures to remove a masking job on an engine. (optional, default to false)
     * @return ApiResponse&lt;DeleteMaskingJobResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job delete initiated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteMaskingJobResponse> deleteMaskingJobWithHttpInfo(String maskingJobId, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = deleteMaskingJobValidateBeforeCall(maskingJobId, force, null);
        Type localVarReturnType = new TypeToken<DeleteMaskingJobResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete a masking job. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param force If true, ignores any failures to remove a masking job on an engine. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job delete initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMaskingJobAsync(String maskingJobId, Boolean force, final ApiCallback<DeleteMaskingJobResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMaskingJobValidateBeforeCall(maskingJobId, force, _callback);
        Type localVarReturnType = new TypeToken<DeleteMaskingJobResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteMaskingJobTag
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param deleteTag The parameters to delete tags (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMaskingJobTagCall(String maskingJobId, DeleteTag deleteTag, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = deleteTag;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/tags/delete"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMaskingJobTagValidateBeforeCall(String maskingJobId, DeleteTag deleteTag, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling deleteMaskingJobTag(Async)");
        }
        

        okhttp3.Call localVarCall = deleteMaskingJobTagCall(maskingJobId, deleteTag, _callback);
        return localVarCall;

    }

    /**
     * Delete tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param deleteTag The parameters to delete tags (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void deleteMaskingJobTag(String maskingJobId, DeleteTag deleteTag) throws ApiException {
        deleteMaskingJobTagWithHttpInfo(maskingJobId, deleteTag);
    }

    /**
     * Delete tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param deleteTag The parameters to delete tags (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteMaskingJobTagWithHttpInfo(String maskingJobId, DeleteTag deleteTag) throws ApiException {
        okhttp3.Call localVarCall = deleteMaskingJobTagValidateBeforeCall(maskingJobId, deleteTag, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete tags for a Masking Job. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param deleteTag The parameters to delete tags (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMaskingJobTagAsync(String maskingJobId, DeleteTag deleteTag, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMaskingJobTagValidateBeforeCall(maskingJobId, deleteTag, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for executeMaskingJob
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param executeMaskingJobParameters  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job execute initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call executeMaskingJobCall(String maskingJobId, ExecuteMaskingJobParameters executeMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = executeMaskingJobParameters;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/execute"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call executeMaskingJobValidateBeforeCall(String maskingJobId, ExecuteMaskingJobParameters executeMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling executeMaskingJob(Async)");
        }
        

        okhttp3.Call localVarCall = executeMaskingJobCall(maskingJobId, executeMaskingJobParameters, _callback);
        return localVarCall;

    }

    /**
     * Execute a MaskingJob.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param executeMaskingJobParameters  (optional)
     * @return ExecuteMaskingJobResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job execute initiated. </td><td>  -  </td></tr>
     </table>
     */
    public ExecuteMaskingJobResponse executeMaskingJob(String maskingJobId, ExecuteMaskingJobParameters executeMaskingJobParameters) throws ApiException {
        ApiResponse<ExecuteMaskingJobResponse> localVarResp = executeMaskingJobWithHttpInfo(maskingJobId, executeMaskingJobParameters);
        return localVarResp.getData();
    }

    /**
     * Execute a MaskingJob.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param executeMaskingJobParameters  (optional)
     * @return ApiResponse&lt;ExecuteMaskingJobResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job execute initiated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ExecuteMaskingJobResponse> executeMaskingJobWithHttpInfo(String maskingJobId, ExecuteMaskingJobParameters executeMaskingJobParameters) throws ApiException {
        okhttp3.Call localVarCall = executeMaskingJobValidateBeforeCall(maskingJobId, executeMaskingJobParameters, null);
        Type localVarReturnType = new TypeToken<ExecuteMaskingJobResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Execute a MaskingJob. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param executeMaskingJobParameters  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Masking job execute initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call executeMaskingJobAsync(String maskingJobId, ExecuteMaskingJobParameters executeMaskingJobParameters, final ApiCallback<ExecuteMaskingJobResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = executeMaskingJobValidateBeforeCall(maskingJobId, executeMaskingJobParameters, _callback);
        Type localVarReturnType = new TypeToken<ExecuteMaskingJobResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMaskingJobById
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobByIdCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMaskingJobByIdValidateBeforeCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling getMaskingJobById(Async)");
        }
        

        okhttp3.Call localVarCall = getMaskingJobByIdCall(maskingJobId, _callback);
        return localVarCall;

    }

    /**
     * Retrieve a MaskingJob by ID.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return MaskingJob
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public MaskingJob getMaskingJobById(String maskingJobId) throws ApiException {
        ApiResponse<MaskingJob> localVarResp = getMaskingJobByIdWithHttpInfo(maskingJobId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a MaskingJob by ID.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return ApiResponse&lt;MaskingJob&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MaskingJob> getMaskingJobByIdWithHttpInfo(String maskingJobId) throws ApiException {
        okhttp3.Call localVarCall = getMaskingJobByIdValidateBeforeCall(maskingJobId, null);
        Type localVarReturnType = new TypeToken<MaskingJob>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a MaskingJob by ID. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobByIdAsync(String maskingJobId, final ApiCallback<MaskingJob> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMaskingJobByIdValidateBeforeCall(maskingJobId, _callback);
        Type localVarReturnType = new TypeToken<MaskingJob>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMaskingJobConnectors
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobConnectorsCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/connectors"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMaskingJobConnectorsValidateBeforeCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling getMaskingJobConnectors(Async)");
        }
        

        okhttp3.Call localVarCall = getMaskingJobConnectorsCall(maskingJobId, _callback);
        return localVarCall;

    }

    /**
     * Get connectors for a Masking Job by ID.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return MaskingJobConnectorsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public MaskingJobConnectorsResponse getMaskingJobConnectors(String maskingJobId) throws ApiException {
        ApiResponse<MaskingJobConnectorsResponse> localVarResp = getMaskingJobConnectorsWithHttpInfo(maskingJobId);
        return localVarResp.getData();
    }

    /**
     * Get connectors for a Masking Job by ID.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return ApiResponse&lt;MaskingJobConnectorsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MaskingJobConnectorsResponse> getMaskingJobConnectorsWithHttpInfo(String maskingJobId) throws ApiException {
        okhttp3.Call localVarCall = getMaskingJobConnectorsValidateBeforeCall(maskingJobId, null);
        Type localVarReturnType = new TypeToken<MaskingJobConnectorsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get connectors for a Masking Job by ID. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobConnectorsAsync(String maskingJobId, final ApiCallback<MaskingJobConnectorsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMaskingJobConnectorsValidateBeforeCall(maskingJobId, _callback);
        Type localVarReturnType = new TypeToken<MaskingJobConnectorsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMaskingJobSourceEngines
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobSourceEnginesCall(Integer limit, String cursor, String sort, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs/source-engines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMaskingJobSourceEnginesValidateBeforeCall(Integer limit, String cursor, String sort, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMaskingJobSourceEnginesCall(limit, cursor, sort, _callback);
        return localVarCall;

    }

    /**
     * Retrieve the list of masking jobs along with their source engine.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @return ListMaskingJobSourceEnginesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ListMaskingJobSourceEnginesResponse getMaskingJobSourceEngines(Integer limit, String cursor, String sort) throws ApiException {
        ApiResponse<ListMaskingJobSourceEnginesResponse> localVarResp = getMaskingJobSourceEnginesWithHttpInfo(limit, cursor, sort);
        return localVarResp.getData();
    }

    /**
     * Retrieve the list of masking jobs along with their source engine.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @return ApiResponse&lt;ListMaskingJobSourceEnginesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ListMaskingJobSourceEnginesResponse> getMaskingJobSourceEnginesWithHttpInfo(Integer limit, String cursor, String sort) throws ApiException {
        okhttp3.Call localVarCall = getMaskingJobSourceEnginesValidateBeforeCall(limit, cursor, sort, null);
        Type localVarReturnType = new TypeToken<ListMaskingJobSourceEnginesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve the list of masking jobs along with their source engine. (asynchronously)
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobSourceEnginesAsync(Integer limit, String cursor, String sort, final ApiCallback<ListMaskingJobSourceEnginesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMaskingJobSourceEnginesValidateBeforeCall(limit, cursor, sort, _callback);
        Type localVarReturnType = new TypeToken<ListMaskingJobSourceEnginesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMaskingJobTag
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobTagCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/tags"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMaskingJobTagValidateBeforeCall(String maskingJobId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling getMaskingJobTag(Async)");
        }
        

        okhttp3.Call localVarCall = getMaskingJobTagCall(maskingJobId, _callback);
        return localVarCall;

    }

    /**
     * Get tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return TagsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public TagsResponse getMaskingJobTag(String maskingJobId) throws ApiException {
        ApiResponse<TagsResponse> localVarResp = getMaskingJobTagWithHttpInfo(maskingJobId);
        return localVarResp.getData();
    }

    /**
     * Get tags for a Masking Job.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @return ApiResponse&lt;TagsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TagsResponse> getMaskingJobTagWithHttpInfo(String maskingJobId) throws ApiException {
        okhttp3.Call localVarCall = getMaskingJobTagValidateBeforeCall(maskingJobId, null);
        Type localVarReturnType = new TypeToken<TagsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get tags for a Masking Job. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Ok </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobTagAsync(String maskingJobId, final ApiCallback<TagsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMaskingJobTagValidateBeforeCall(maskingJobId, _callback);
        Type localVarReturnType = new TypeToken<TagsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMaskingJobs
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobsCall(Integer limit, String cursor, String sort, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/masking-jobs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMaskingJobsValidateBeforeCall(Integer limit, String cursor, String sort, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = getMaskingJobsCall(limit, cursor, sort, _callback);
        return localVarCall;

    }

    /**
     * Retrieve the list of masking jobs.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @return ListMaskingJobsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ListMaskingJobsResponse getMaskingJobs(Integer limit, String cursor, String sort) throws ApiException {
        ApiResponse<ListMaskingJobsResponse> localVarResp = getMaskingJobsWithHttpInfo(limit, cursor, sort);
        return localVarResp.getData();
    }

    /**
     * Retrieve the list of masking jobs.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @return ApiResponse&lt;ListMaskingJobsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ListMaskingJobsResponse> getMaskingJobsWithHttpInfo(Integer limit, String cursor, String sort) throws ApiException {
        okhttp3.Call localVarCall = getMaskingJobsValidateBeforeCall(limit, cursor, sort, null);
        Type localVarReturnType = new TypeToken<ListMaskingJobsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve the list of masking jobs. (asynchronously)
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMaskingJobsAsync(Integer limit, String cursor, String sort, final ApiCallback<ListMaskingJobsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMaskingJobsValidateBeforeCall(limit, cursor, sort, _callback);
        Type localVarReturnType = new TypeToken<ListMaskingJobsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for migrateMaskingJob
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param migrateMaskingJobParameters  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Migrate masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call migrateMaskingJobCall(String maskingJobId, MigrateMaskingJobParameters migrateMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = migrateMaskingJobParameters;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}/migrate"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call migrateMaskingJobValidateBeforeCall(String maskingJobId, MigrateMaskingJobParameters migrateMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling migrateMaskingJob(Async)");
        }
        

        okhttp3.Call localVarCall = migrateMaskingJobCall(maskingJobId, migrateMaskingJobParameters, _callback);
        return localVarCall;

    }

    /**
     * Migrates the masking job from its current source engine to another engine.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param migrateMaskingJobParameters  (optional)
     * @return MigrateMaskingJobResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Migrate masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public MigrateMaskingJobResponse migrateMaskingJob(String maskingJobId, MigrateMaskingJobParameters migrateMaskingJobParameters) throws ApiException {
        ApiResponse<MigrateMaskingJobResponse> localVarResp = migrateMaskingJobWithHttpInfo(maskingJobId, migrateMaskingJobParameters);
        return localVarResp.getData();
    }

    /**
     * Migrates the masking job from its current source engine to another engine.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param migrateMaskingJobParameters  (optional)
     * @return ApiResponse&lt;MigrateMaskingJobResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Migrate masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MigrateMaskingJobResponse> migrateMaskingJobWithHttpInfo(String maskingJobId, MigrateMaskingJobParameters migrateMaskingJobParameters) throws ApiException {
        okhttp3.Call localVarCall = migrateMaskingJobValidateBeforeCall(maskingJobId, migrateMaskingJobParameters, null);
        Type localVarReturnType = new TypeToken<MigrateMaskingJobResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Migrates the masking job from its current source engine to another engine. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param migrateMaskingJobParameters  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Migrate masking job initiated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call migrateMaskingJobAsync(String maskingJobId, MigrateMaskingJobParameters migrateMaskingJobParameters, final ApiCallback<MigrateMaskingJobResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = migrateMaskingJobValidateBeforeCall(maskingJobId, migrateMaskingJobParameters, _callback);
        Type localVarReturnType = new TypeToken<MigrateMaskingJobResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchMaskingJobSourceEngines
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchMaskingJobSourceEnginesCall(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = searchBody;

        // create path and map variables
        String localVarPath = "/masking-jobs/source-engines/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchMaskingJobSourceEnginesValidateBeforeCall(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = searchMaskingJobSourceEnginesCall(limit, cursor, sort, searchBody, _callback);
        return localVarCall;

    }

    /**
     * Search the list of masking jobs along with their source engine.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @return SearchMaskingJobSourceEnginesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public SearchMaskingJobSourceEnginesResponse searchMaskingJobSourceEngines(Integer limit, String cursor, String sort, SearchBody searchBody) throws ApiException {
        ApiResponse<SearchMaskingJobSourceEnginesResponse> localVarResp = searchMaskingJobSourceEnginesWithHttpInfo(limit, cursor, sort, searchBody);
        return localVarResp.getData();
    }

    /**
     * Search the list of masking jobs along with their source engine.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @return ApiResponse&lt;SearchMaskingJobSourceEnginesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchMaskingJobSourceEnginesResponse> searchMaskingJobSourceEnginesWithHttpInfo(Integer limit, String cursor, String sort, SearchBody searchBody) throws ApiException {
        okhttp3.Call localVarCall = searchMaskingJobSourceEnginesValidateBeforeCall(limit, cursor, sort, searchBody, null);
        Type localVarReturnType = new TypeToken<SearchMaskingJobSourceEnginesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search the list of masking jobs along with their source engine. (asynchronously)
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchMaskingJobSourceEnginesAsync(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback<SearchMaskingJobSourceEnginesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchMaskingJobSourceEnginesValidateBeforeCall(limit, cursor, sort, searchBody, _callback);
        Type localVarReturnType = new TypeToken<SearchMaskingJobSourceEnginesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchMaskingJobs
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchMaskingJobsCall(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = searchBody;

        // create path and map variables
        String localVarPath = "/masking-jobs/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchMaskingJobsValidateBeforeCall(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = searchMaskingJobsCall(limit, cursor, sort, searchBody, _callback);
        return localVarCall;

    }

    /**
     * Search masking jobs.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @return SearchMaskingJobsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public SearchMaskingJobsResponse searchMaskingJobs(Integer limit, String cursor, String sort, SearchBody searchBody) throws ApiException {
        ApiResponse<SearchMaskingJobsResponse> localVarResp = searchMaskingJobsWithHttpInfo(limit, cursor, sort, searchBody);
        return localVarResp.getData();
    }

    /**
     * Search masking jobs.
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @return ApiResponse&lt;SearchMaskingJobsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchMaskingJobsResponse> searchMaskingJobsWithHttpInfo(Integer limit, String cursor, String sort, SearchBody searchBody) throws ApiException {
        okhttp3.Call localVarCall = searchMaskingJobsValidateBeforeCall(limit, cursor, sort, searchBody, null);
        Type localVarReturnType = new TypeToken<SearchMaskingJobsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search masking jobs. (asynchronously)
     * 
     * @param limit Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (optional, default to 100)
     * @param cursor Cursor to fetch the next or previous page of results. The value of this property must be extracted from the &#39;prev_cursor&#39; or &#39;next_cursor&#39; property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (optional)
     * @param sort The field to sort results by. A property name with a prepended &#39;-&#39; signifies a descending order. (optional)
     * @param searchBody A request body containing a filter expression. This enables searching for items matching arbitrarily complex conditions. The list of attributes which can be used in filter expressions is available in the x-filterable vendor extension.  # Filter Expression Overview **Note: All keywords are case-insensitive**  ## Comparison Operators | Operator | Description | Example | | --- | --- | --- | | CONTAINS | Substring or membership testing for string and list attributes respectively. | field3 CONTAINS &#39;foobar&#39;, field4 CONTAINS TRUE  | | IN | Tests if field is a member of a list literal. List can contain a maximum of 100 values | field2 IN [&#39;Goku&#39;, &#39;Vegeta&#39;] | | GE | Tests if a field is greater than or equal to a literal value | field1 GE 1.2e-2 | | GT | Tests if a field is greater than a literal value | field1 GT 1.2e-2 | | LE | Tests if a field is less than or equal to a literal value | field1 LE 9000 | | LT | Tests if a field is less than a literal value | field1 LT 9.02 | | NE | Tests if a field is not equal to a literal value | field1 NE 42 | | EQ | Tests if a field is equal to a literal value | field1 EQ 42 |  ## Search Operator The SEARCH operator filters for items which have any filterable attribute that contains the input string as a substring, comparison is done case-insensitively. This is not restricted to attributes with string values. Specifically &#x60;SEARCH &#39;12&#39;&#x60; would match an item with an attribute with an integer value of &#x60;123&#x60;.  ## Logical Operators Ordered by precedence. | Operator | Description | Example | | --- | --- | --- | | NOT | Logical NOT (Right associative) | NOT field1 LE 9000 | | AND | Logical AND (Left Associative) | field1 GT 9000 AND field2 EQ &#39;Goku&#39; | | OR | Logical OR (Left Associative) | field1 GT 9000 OR field2 EQ &#39;Goku&#39; |  ## Grouping Parenthesis &#x60;()&#x60; can be used to override operator precedence.  For example: NOT (field1 LT 1234 AND field2 CONTAINS &#39;foo&#39;)  ## Literal Values | Literal      | Description | Examples | | --- | --- | --- | | Nil | Represents the absence of a value | nil, Nil, nIl, NIL | | Boolean | true/false boolean | true, false, True, False, TRUE, FALSE | | Number | Signed integer and floating point numbers. Also supports scientific notation. | 0, 1, -1, 1.2, 0.35, 1.2e-2, -1.2e+2 | | String | Single or double quoted | \&quot;foo\&quot;, \&quot;bar\&quot;, \&quot;foo bar\&quot;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo bar&#39; | | Datetime | Formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) | 2018-04-27T18:39:26.397237+00:00 | | List | Comma-separated literals wrapped in square brackets | [0], [0, 1], [&#39;foo&#39;, \&quot;bar\&quot;] |  ## Limitations - A maximum of 8 unique identifiers may be used inside a filter expression.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchMaskingJobsAsync(Integer limit, String cursor, String sort, SearchBody searchBody, final ApiCallback<SearchMaskingJobsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchMaskingJobsValidateBeforeCall(limit, cursor, sort, searchBody, _callback);
        Type localVarReturnType = new TypeToken<SearchMaskingJobsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateMaskingJobById
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param updateMaskingJobParameters The new data to update a Masking Job. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateMaskingJobByIdCall(String maskingJobId, UpdateMaskingJobParameters updateMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = updateMaskingJobParameters;

        // create path and map variables
        String localVarPath = "/masking-jobs/{maskingJobId}"
            .replaceAll("\\{" + "maskingJobId" + "\\}", localVarApiClient.escapeString(maskingJobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateMaskingJobByIdValidateBeforeCall(String maskingJobId, UpdateMaskingJobParameters updateMaskingJobParameters, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'maskingJobId' is set
        if (maskingJobId == null) {
            throw new ApiException("Missing the required parameter 'maskingJobId' when calling updateMaskingJobById(Async)");
        }
        

        okhttp3.Call localVarCall = updateMaskingJobByIdCall(maskingJobId, updateMaskingJobParameters, _callback);
        return localVarCall;

    }

    /**
     * Update values of a MaskingJob.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param updateMaskingJobParameters The new data to update a Masking Job. (optional)
     * @return MaskingJob
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public MaskingJob updateMaskingJobById(String maskingJobId, UpdateMaskingJobParameters updateMaskingJobParameters) throws ApiException {
        ApiResponse<MaskingJob> localVarResp = updateMaskingJobByIdWithHttpInfo(maskingJobId, updateMaskingJobParameters);
        return localVarResp.getData();
    }

    /**
     * Update values of a MaskingJob.
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param updateMaskingJobParameters The new data to update a Masking Job. (optional)
     * @return ApiResponse&lt;MaskingJob&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MaskingJob> updateMaskingJobByIdWithHttpInfo(String maskingJobId, UpdateMaskingJobParameters updateMaskingJobParameters) throws ApiException {
        okhttp3.Call localVarCall = updateMaskingJobByIdValidateBeforeCall(maskingJobId, updateMaskingJobParameters, null);
        Type localVarReturnType = new TypeToken<MaskingJob>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update values of a MaskingJob. (asynchronously)
     * 
     * @param maskingJobId The ID of the Masking Job. (required)
     * @param updateMaskingJobParameters The new data to update a Masking Job. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateMaskingJobByIdAsync(String maskingJobId, UpdateMaskingJobParameters updateMaskingJobParameters, final ApiCallback<MaskingJob> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateMaskingJobByIdValidateBeforeCall(maskingJobId, updateMaskingJobParameters, _callback);
        Type localVarReturnType = new TypeToken<MaskingJob>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
