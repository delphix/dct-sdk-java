/*
 * Delphix DCT API
 * Delphix DCT API
 *
 * The version of the OpenAPI document: 3.10.0
 * Contact: support@delphix.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.delphix.dct.models;

import java.util.Objects;
import com.delphix.dct.models.HyperscaleDataTypeEnum;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.delphix.dct.JSON;

/**
 * Parameters to update a Hyperscale instances.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-03T12:02:33.321319+05:30[Asia/Kolkata]", comments = "Generator version: 7.4.0")
public class HyperscaleInstanceUpdateParams {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_HOSTNAME = "hostname";
  @SerializedName(SERIALIZED_NAME_HOSTNAME)
  private String hostname;

  public static final String SERIALIZED_NAME_API_KEY = "api_key";
  @SerializedName(SERIALIZED_NAME_API_KEY)
  private String apiKey;

  public static final String SERIALIZED_NAME_DATA_TYPE = "data_type";
  @SerializedName(SERIALIZED_NAME_DATA_TYPE)
  private HyperscaleDataTypeEnum dataType;

  public static final String SERIALIZED_NAME_INSECURE_SSL = "insecure_ssl";
  @SerializedName(SERIALIZED_NAME_INSECURE_SSL)
  private Boolean insecureSsl;

  public static final String SERIALIZED_NAME_UNSAFE_SSL_HOSTNAME_CHECK = "unsafe_ssl_hostname_check";
  @SerializedName(SERIALIZED_NAME_UNSAFE_SSL_HOSTNAME_CHECK)
  private Boolean unsafeSslHostnameCheck;

  public static final String SERIALIZED_NAME_TRUSTSTORE_FILENAME = "truststore_filename";
  @SerializedName(SERIALIZED_NAME_TRUSTSTORE_FILENAME)
  private String truststoreFilename;

  public static final String SERIALIZED_NAME_TRUSTSTORE_PASSWORD = "truststore_password";
  @SerializedName(SERIALIZED_NAME_TRUSTSTORE_PASSWORD)
  private String truststorePassword;

  public HyperscaleInstanceUpdateParams() {
  }

  public HyperscaleInstanceUpdateParams name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name in DCT of the Hyperscale instance.
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public HyperscaleInstanceUpdateParams hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

   /**
   * Hostname of the Hyperscale instance.
   * @return hostname
  **/
  @javax.annotation.Nullable
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }


  public HyperscaleInstanceUpdateParams apiKey(String apiKey) {
    this.apiKey = apiKey;
    return this;
  }

   /**
   * API key to connect to the Hyperscale instance.
   * @return apiKey
  **/
  @javax.annotation.Nullable
  public String getApiKey() {
    return apiKey;
  }

  public void setApiKey(String apiKey) {
    this.apiKey = apiKey;
  }


  public HyperscaleInstanceUpdateParams dataType(HyperscaleDataTypeEnum dataType) {
    this.dataType = dataType;
    return this;
  }

   /**
   * Get dataType
   * @return dataType
  **/
  @javax.annotation.Nullable
  public HyperscaleDataTypeEnum getDataType() {
    return dataType;
  }

  public void setDataType(HyperscaleDataTypeEnum dataType) {
    this.dataType = dataType;
  }


  public HyperscaleInstanceUpdateParams insecureSsl(Boolean insecureSsl) {
    this.insecureSsl = insecureSsl;
    return this;
  }

   /**
   * Allow connections to the hyperscale instance over HTTPs without validating the TLS certificate. Even though the connection to the hyperscale instance might be performed over HTTPs, setting this property eliminates the protection against a man-in-the-middle attach for connections to this engine. Instead, consider creating a truststore with a Certificate Authority to validate the hyperscale instance&#39;s certificate, and set the truststore_filename property. 
   * @return insecureSsl
  **/
  @javax.annotation.Nullable
  public Boolean getInsecureSsl() {
    return insecureSsl;
  }

  public void setInsecureSsl(Boolean insecureSsl) {
    this.insecureSsl = insecureSsl;
  }


  public HyperscaleInstanceUpdateParams unsafeSslHostnameCheck(Boolean unsafeSslHostnameCheck) {
    this.unsafeSslHostnameCheck = unsafeSslHostnameCheck;
    return this;
  }

   /**
   * Ignore validation of the name associated to the TLS certificate when connecting to the hyperscale instance over HTTPs. Setting this value must only be done if the TLS certificate of the hyperscale instance does not match the hostname, and the TLS configuration of the hyperscale instance cannot be fixed. Setting this property reduces the protection against a man-in-the-middle attack for connections to this engine. This is ignored if insecure_ssl is set. 
   * @return unsafeSslHostnameCheck
  **/
  @javax.annotation.Nullable
  public Boolean getUnsafeSslHostnameCheck() {
    return unsafeSslHostnameCheck;
  }

  public void setUnsafeSslHostnameCheck(Boolean unsafeSslHostnameCheck) {
    this.unsafeSslHostnameCheck = unsafeSslHostnameCheck;
  }


  public HyperscaleInstanceUpdateParams truststoreFilename(String truststoreFilename) {
    this.truststoreFilename = truststoreFilename;
    return this;
  }

   /**
   * File name of a truststore which can be used to validate the TLS certificate of the hyperscale instance. The truststore must be available at /etc/config/certs/&lt;truststore_filename&gt;. Set this property to an empty string to clear the value. 
   * @return truststoreFilename
  **/
  @javax.annotation.Nullable
  public String getTruststoreFilename() {
    return truststoreFilename;
  }

  public void setTruststoreFilename(String truststoreFilename) {
    this.truststoreFilename = truststoreFilename;
  }


  public HyperscaleInstanceUpdateParams truststorePassword(String truststorePassword) {
    this.truststorePassword = truststorePassword;
    return this;
  }

   /**
   * Password to read the truststore. Set this property to an empty string to clear the value. 
   * @return truststorePassword
  **/
  @javax.annotation.Nullable
  public String getTruststorePassword() {
    return truststorePassword;
  }

  public void setTruststorePassword(String truststorePassword) {
    this.truststorePassword = truststorePassword;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HyperscaleInstanceUpdateParams hyperscaleInstanceUpdateParams = (HyperscaleInstanceUpdateParams) o;
    return Objects.equals(this.name, hyperscaleInstanceUpdateParams.name) &&
        Objects.equals(this.hostname, hyperscaleInstanceUpdateParams.hostname) &&
        Objects.equals(this.apiKey, hyperscaleInstanceUpdateParams.apiKey) &&
        Objects.equals(this.dataType, hyperscaleInstanceUpdateParams.dataType) &&
        Objects.equals(this.insecureSsl, hyperscaleInstanceUpdateParams.insecureSsl) &&
        Objects.equals(this.unsafeSslHostnameCheck, hyperscaleInstanceUpdateParams.unsafeSslHostnameCheck) &&
        Objects.equals(this.truststoreFilename, hyperscaleInstanceUpdateParams.truststoreFilename) &&
        Objects.equals(this.truststorePassword, hyperscaleInstanceUpdateParams.truststorePassword);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, hostname, apiKey, dataType, insecureSsl, unsafeSslHostnameCheck, truststoreFilename, truststorePassword);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HyperscaleInstanceUpdateParams {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    apiKey: ").append(toIndentedString(apiKey)).append("\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    insecureSsl: ").append(toIndentedString(insecureSsl)).append("\n");
    sb.append("    unsafeSslHostnameCheck: ").append(toIndentedString(unsafeSslHostnameCheck)).append("\n");
    sb.append("    truststoreFilename: ").append(toIndentedString(truststoreFilename)).append("\n");
    sb.append("    truststorePassword: ").append(toIndentedString(truststorePassword)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("hostname");
    openapiFields.add("api_key");
    openapiFields.add("data_type");
    openapiFields.add("insecure_ssl");
    openapiFields.add("unsafe_ssl_hostname_check");
    openapiFields.add("truststore_filename");
    openapiFields.add("truststore_password");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to HyperscaleInstanceUpdateParams
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HyperscaleInstanceUpdateParams.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HyperscaleInstanceUpdateParams is not found in the empty JSON string", HyperscaleInstanceUpdateParams.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HyperscaleInstanceUpdateParams.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HyperscaleInstanceUpdateParams` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("hostname") != null && !jsonObj.get("hostname").isJsonNull()) && !jsonObj.get("hostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname").toString()));
      }
      if ((jsonObj.get("api_key") != null && !jsonObj.get("api_key").isJsonNull()) && !jsonObj.get("api_key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `api_key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("api_key").toString()));
      }
      // validate the optional field `data_type`
      if (jsonObj.get("data_type") != null && !jsonObj.get("data_type").isJsonNull()) {
        HyperscaleDataTypeEnum.validateJsonElement(jsonObj.get("data_type"));
      }
      if ((jsonObj.get("truststore_filename") != null && !jsonObj.get("truststore_filename").isJsonNull()) && !jsonObj.get("truststore_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `truststore_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("truststore_filename").toString()));
      }
      if ((jsonObj.get("truststore_password") != null && !jsonObj.get("truststore_password").isJsonNull()) && !jsonObj.get("truststore_password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `truststore_password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("truststore_password").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HyperscaleInstanceUpdateParams.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HyperscaleInstanceUpdateParams' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HyperscaleInstanceUpdateParams> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HyperscaleInstanceUpdateParams.class));

       return (TypeAdapter<T>) new TypeAdapter<HyperscaleInstanceUpdateParams>() {
           @Override
           public void write(JsonWriter out, HyperscaleInstanceUpdateParams value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HyperscaleInstanceUpdateParams read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of HyperscaleInstanceUpdateParams given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of HyperscaleInstanceUpdateParams
  * @throws IOException if the JSON string is invalid with respect to HyperscaleInstanceUpdateParams
  */
  public static HyperscaleInstanceUpdateParams fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HyperscaleInstanceUpdateParams.class);
  }

 /**
  * Convert an instance of HyperscaleInstanceUpdateParams to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

